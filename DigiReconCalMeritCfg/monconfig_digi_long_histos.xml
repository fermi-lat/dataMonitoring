<monitoring>

  <inputList name="top"> 

  
    <!-- Time stamp -->
    <object> timestampdouble </object>
    <object> timestamp </object> <!-- some functions need time stamp as int -->

    <!-- Event classification information -->
    <object> condsummary </object>
    <object> Range4 </object>
    <object> ZeroSuppress </object>
    <object> DeltaEventTime </object>

    <!-- Acd Variables -->
    <object>AcdPha_PmtIdPmtRangeAcdTile</object>
    <object>AcdVetoA_AcdTile</object>
    <object>AcdVetoB_AcdTile</object>
    <object>AcdPmtA_OverThreshold_AcdTile</object>
    <object>AcdPmtB_OverThreshold_AcdTile</object>
    
    <!-- Tkr Variables -->
 
     <!-- Cal Variables -->
   
    <object> CalXAdc_TowerCalLayerCalColumnFaceRange </object>

  </inputList>


  <outputList name="top">
  
    

<!-- TRENDING QUANTITIES THAT WILL BE USED TO PRODUCE THE FINAL HISTOGRAMS. THIS IS NEEDED TO USE THE FEATURES 
OF THE TRUNCATED MEAN RELATED OBJECTS -->
 
      <!-- ACD -->

      <object>
	<name>  AcdPedestal_PmtA_LowPMTRange_AcdTile[128] </name>
	<formula><![CDATA[AcdPha_PmtIdPmtRangeAcdTile[0][0] ]]></formula>
	<cut><![CDATA[condsummary==32 && (!ZeroSuppress)]]></cut>
	<type> truncatedmeanboundandfracbigdataequaln[0,100000,0.96] </type>
	<description> Vector [AcdTile] reporting the mean (and rms by means of the quantity AcdPedestal_PmtA_LowPMTRAnge_AcdTile_err) pedestal for the LOW range of PMT A during the specified time bin. The mean (and rms) is computed removing (truncating) 2 percent of the events located at each of the sides (beginning+end) of the distribution of values; that is with the 96 percent central values. </description>
      </object>

	<object>
	<name>  AcdPedestal_PmtB_LowPMTRange_AcdTile[128] </name>
	<formula><![CDATA[AcdPha_PmtIdPmtRangeAcdTile[1][0] ]]></formula>
	<cut><![CDATA[condsummary==32 && (!ZeroSuppress)]]></cut>
	<type> truncatedmeanboundandfracbigdataequaln[0,100000,0.96] </type>
	<description> Vector [AcdTile] reporting the mean (and rms by means of the quantity AcdPedestal_PmtB_HighPMTRAnge_AcdTile_err) pedestal for the LOW range of PMT B during the specified time bin. The mean (and rms) is computed removing (truncating) 2 percent of the events located at each of the sides (beginning+end) of the distribution of values; that is with the 96 percent central values. </description>
      </object>



     <object>
	<name> AcdVetoA_AcdTile[128]  </name>
	<formula><![CDATA[ foreachacdtile: AcdVetoA_AcdTile[acdtile] ]]></formula>
	<cut><![CDATA[condsummary&30]]></cut>
	<type> counter </type>
	<description> Vector[AcdTile] reporting the number of vetos from PMT A.</description>
      </object>

	<object>
	<name> AcdVetoB_AcdTile[128]  </name>
	<formula><![CDATA[ foreachacdtile: AcdVetoB_AcdTile[acdtile] ]]></formula>
	<cut><![CDATA[condsummary&30]]></cut>
	<type> counter </type>
	<description> Vector[AcdTile] reporting the number of vetos from PMT B. </description>
      </object>
    

	<object>
	<name> AnyAcdVeto_AcdTile[128]  </name>
	<formula><![CDATA[ foreachacdtile:  AcdVetoA_AcdTile[acdtile] || AcdVetoB_AcdTile[acdtile]   ]]></formula>
	<cut><![CDATA[condsummary&30]]></cut>
	<type> counter </type>
	<description> Vector[AcdTile] reporting the number of ACD Vetos (produced by one or by the two PMTs).  </description>
      </object>



      <object>
	<name> AcdPmtA_OverThreshold_AcdTile[128] </name>
	<formula><![CDATA[ foreachacdtile: AcdPmtA_OverThreshold_AcdTile[acdtile]]]></formula>
	<cut><![CDATA[condsummary&30]]></cut>
	<type> counter </type>
	<description> Vector[AcdTile] reporting the number of PMT A being above threshold. </description>
      </object>



      
       <object>
	<name> AcdPmtB_OverThreshold_AcdTile[128] </name>
	<formula><![CDATA[foreachacdtile: AcdPmtB_OverThreshold_AcdTile[acdtile] ]]></formula>
	<cut><![CDATA[condsummary&30]]></cut>
	<type> counter </type>
	<description>Vector[AcdTile] reporting the number of PMT B being above threshold.</description>
      </object>


       <object>
	<name> AnyAcdPmt_OverThreshold_AcdTile[128] </name>
	<formula><![CDATA[foreachacdtile: AcdPmtA_OverThreshold_AcdTile[acdtile] || AcdPmtB_OverThreshold_AcdTile[acdtile]]]></formula>
	<cut><![CDATA[condsummary&30]]></cut>
	<type> counter </type>
	<description>Vector[AcdTile] reporting the number of at least one PMT being above threshold. </description>
      </object>

   

      <!-- Calorimeter -->

     <object>
      <name> CalXAdc_LEX8_TowerCalLayerCalColumnF[16][8][12][2] </name>
      <formula><![CDATA[ foreachtower: foreachcallayer: foreachcalcolumn: foreachcalxface: CalXAdc_TowerCalLayerCalColumnFaceRange[tower][callayer][calcolumn][calxface][0]]]></formula>
      <cut><![CDATA[ condsummary==32 && Range4 && (!ZeroSuppress) && (DeltaEventTime>2000)]]></cut>
      <type> truncatedmeanboundandfracbigdataequaln[0,100000,0.96]  </type>     
      <description> Vector[tower][callayer][calcolumn][face] reporting the mean (and rms by means of the the CalXAdc_TowerCalLayerCalColumnF_err quantity) pedestal for LEX8. The mean (and rms) is computed removing (truncating) 2 percent of the events located at each of the sides (beginning+end) of the distribution of values; that is with the 96 percent central values. This is done to remove outliers. Only periodic triggers with 4 range readout events are being used. </description>
     </object>


        <object>
      <name> CalXAdc_LEX1_TowerCalLayerCalColumnF[16][8][12][2] </name>
      <formula><![CDATA[ foreachtower: foreachcallayer: foreachcalcolumn: foreachcalxface: CalXAdc_TowerCalLayerCalColumnFaceRange[tower][callayer][calcolumn][calxface][1]]]></formula>
      <cut><![CDATA[ condsummary==32 && Range4 && (!ZeroSuppress)  && (DeltaEventTime>2000)]]></cut>
      <type> truncatedmeanboundandfracbigdataequaln[0,100000,0.96]  </type>     
      <description> Vector[tower][callayer][calcolumn][face] reporting the mean (and rms by means of the the CalXAdc_TowerCalLayerCalColumnF_err quantity) pedestal for LEX1. The mean (and rms) is computed removing (truncating) 2 percent of the events located at each of the sides (beginning+end) of the distribution of values; that is with the 96 percent central values. This is done to remove outliers. Only periodic triggers with 4 range readout events are being used. </description>
     </object>


	    <object>
      <name> CalXAdc_HEX8_TowerCalLayerCalColumnF[16][8][12][2] </name>
      <formula><![CDATA[ foreachtower: foreachcallayer: foreachcalcolumn: foreachcalxface: CalXAdc_TowerCalLayerCalColumnFaceRange[tower][callayer][calcolumn][calxface][2]]]></formula>
      <cut><![CDATA[ condsummary==32 && Range4 && (!ZeroSuppress)  && (DeltaEventTime>2000)]]></cut>
      <type>truncatedmeanboundandfracbigdataequaln[0,100000,0.96]  </type>     
      <description> Vector[tower][callayer][calcolumn][face] reporting the mean (and rms by means of the the CalXAdc_TowerCalLayerCalColumnF_err quantity) pedestal for HEX8. The mean (and rms) is computed removing (truncating) 2 percent of the events located at each of the sides (beginning+end) of the distribution of values; that is with the 96 percent central values. This is done to remove outliers. Only periodic triggers with 4 range readout events are being used. </description>
     </object>


        <object>
      <name> CalXAdc_HEX1_TowerCalLayerCalColumnF[16][8][12][2] </name>
      <formula><![CDATA[ foreachtower: foreachcallayer: foreachcalcolumn: foreachcalxface: CalXAdc_TowerCalLayerCalColumnFaceRange[tower][callayer][calcolumn][calxface][3]]]></formula>
      <cut><![CDATA[ condsummary==32 && Range4 && (!ZeroSuppress)  && (DeltaEventTime>2000) ]]></cut>
      <type> truncatedmeanboundandfracbigdataequaln[0,100000,0.96]  </type>     
      <description> Vector[tower][callayer][calcolumn][face] reporting the mean (and rms by means of the the CalXAdc_TowerCalLayerCalColumnF_err quantity) pedestal for HEX1. The mean (and rms) is computed removing (truncating) 4 percent of the events located at each of the sides (beginning+end) of the distribution of values; that is with the 96 percent central values. This is done to remove outliers. Only periodic triggers with 4 range readout events are being used. </description>
     </object>

     
      <object>
      <name> CalXPedDev_TowerCalLayerCalColumnFR[16][8][12][2][4] </name>
      <formula><![CDATA[foreachtower:foreachcallayer:foreachcalcolumn:foreachcalxface: foreachcalxrange: CalXAdc_TowerCalLayerCalColumnFaceRange[tower][callayer][calcolumn][calxface][calxrange] - RFun::calped(timestamp,tower,callayer,calcolumn,calxface,calxrange)]]></formula>
      <cut><![CDATA[condsummary==32 && Range4 && (!ZeroSuppress)  && (DeltaEventTime>2000) ]]></cut>
      <type> truncatedmeanboundandfracbigdataequaln[-10000,10000,0.96]  </type>
      <description> Vector[tower][callayer][calcolumn][face][range] reporting the mean deviations between the measured pedestals and the ones retrieved from the data base (and rms by means of the the CalXPedDev_TowerCalLayerCalColumnFR_err quantity). The mean (and rms) is computed removing (truncating) 4 percent of the events located at each of the sides (beginning+end) of the distribution of values; that is with the 96 percent central values. Only periodic triggers with 4 range readout events are being used. </description>
    </object>



      <object>
      <name> RPM_TowerCalLayerCalColumn[16][8][12] </name>
      <formula><![CDATA[foreachtower:foreachcallayer:foreachcalcolumn: RFun::computeratio(CalXAdc_TowerCalLayerCalColumnFaceRange[tower][callayer][calcolumn][0][1],RFun::calped(timestamp,tower,callayer,calcolumn,0,1), CalXAdc_TowerCalLayerCalColumnFaceRange[tower][callayer][calcolumn][1][1], RFun::calped(timestamp,tower,callayer,calcolumn,1,1), 50)]]></formula>
      <cut><![CDATA[!(condsummary&32) && Range4]]></cut>
      <type> truncatedmeanboundandfracbigdata[0,70000,0.96] </type>
      <description> Vector[tower][callayer][calcolumn] reporting the mean ratio LEX1(plus face) / LEX1(minus face) = P/M. This ratio is expected to be close to 1. Pedestals (extracted from data base) are subtracted before computing the ratio. The mean is computed excluding the tails up to a fraction of 0.02 on each side in order to remove outliers; that is with the 96 percent of central values. Only 4 range readout events which are NOT periodic triggers are being used. A minimum signal (after pedestal subtraction) of 50 ADC counts is required. </description>
    </object>


      <object>
      <name> RPp_TowerCalLayerCalColumn[16][8][12] </name>
      <formula><![CDATA[foreachtower:foreachcallayer:foreachcalcolumn: RFun::computeratio_v2(CalXAdc_TowerCalLayerCalColumnFaceRange[tower][callayer][calcolumn][0][1],RFun::calped(timestamp,tower,callayer,calcolumn,0,1), 500, CalXAdc_TowerCalLayerCalColumnFaceRange[tower][callayer][calcolumn][0][2], RFun::calped(timestamp,tower,callayer,calcolumn,0,2), 50)]]></formula>
      <cut><![CDATA[!(condsummary&32) && Range4]]></cut>
      <type> truncatedmeanboundandfracbigdata[0,70000,0.96] </type>
      <description> Vector[tower][callayer][calcolumn] reporting the mean ratio LEX1(plus face) / HEX8 (plus face) = P/p. This ratio is expected to be close to 6. Pedestals (extracted from data base) are subtracted before computing the ratio. The mean is computed excluding the tails up to a fraction of 0.02 on each side in order to remove outliers; that is with the 96 percent of central values.  Only 4 range readout events which are NOT periodic triggers are being used. A minimum signal (after pedestal subtraction) of 50 ADC counts is required. </description>
    </object>

       <object>
      <name> RMm_TowerCalLayerCalColumn[16][8][12] </name>
      <formula><![CDATA[foreachtower:foreachcallayer:foreachcalcolumn: RFun::computeratio_v2(CalXAdc_TowerCalLayerCalColumnFaceRange[tower][callayer][calcolumn][1][1],RFun::calped(timestamp,tower,callayer,calcolumn,1,1), 500, CalXAdc_TowerCalLayerCalColumnFaceRange[tower][callayer][calcolumn][1][2], RFun::calped(timestamp,tower,callayer,calcolumn,1,2), 50)]]></formula>
      <cut><![CDATA[!(condsummary&32) && Range4]]></cut>
      <type>  truncatedmeanboundandfracbigdata[0,70000,0.96] </type>
      <description> Vector[tower][callayer][calcolumn] reporting the mean ratio LEX1(minus face) / HEX8(minus face) = M/m. This ratio is expected to be close to 6. Pedestals (extracted from data base) are subtracted before computing the ratio. The mean is computed excluding the tails up to a fraction of 0.02 on each side in order to remove outliers; that is with the 96 percent of central values.  Only 4 range readout events which are NOT periodic triggers are being used. A minimum signal (after pedestal subtraction) of 50 ADC counts is required. </description>
    </object>
      
     



<!--  END OF TRENDING QUANTITIES -->


<!-- BEGINNING OF HISTOGRAM QUANTITIES -->

 <object>
      <name> Range4Periodic_TH1 </name>
     <formula><![CDATA[  Range4 ]]></formula>
      <cut><![CDATA[condsummary&32]]></cut>
      <type> histogram-1d[2,-0.5,1.5] </type>
      <titledesc> Readout range for periodic triggers</titledesc>
	<axisdesc> [Range4, N] </axisdesc>
      <description> Distribution of Readout range for periodic triggers. ZERO means autorange, ONE means 4-range readout. </description>
    </object>

      <object>
      <name> Range4AllEvents_TH1 </name>
     <formula><![CDATA[  Range4 ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <type> histogram-1d[2,-0.5,1.5] </type>
      <titledesc> Readout range</titledesc>
	<axisdesc> [Range4, N] </axisdesc>
      <description> Distribution of Readout range. ZERO means autorange, ONE means 4-range readout. </description>
    </object>

      <object>
      <name> ZeroSuppressForPeriodicAndRange4_TH1 </name>
     <formula><![CDATA[ ZeroSuppress  ]]></formula>
      <cut><![CDATA[ condsummary&32 && Range4]]></cut>
      <type> histogram-1d[2,-0.5,1.5] </type>
      <titledesc> Zero Suppressed bit</titledesc>
	<axisdesc> [ZeroSuppress, N] </axisdesc>
      <description> Distribution of Zero Suppress bit. ZERO means evt is NOT zero-suppressed, ONE means it is zero-suppressed. Only periodic triggers with 4 range readout are being considered.</description>
    </object>


      <!-- ACD -->

      
      <object>
	<name> ACD_Ped_PMTA_LowRange_TH1_AcdTile[128]</name>
	 <formula><![CDATA[AcdPha_PmtIdPmtRangeAcdTile[0][0]]]></formula>
	 <cut><![CDATA[ condsummary==32 && (!ZeroSuppress)]]></cut>
	 <type> histogram-1d[1001,0,1001, -1] </type>
	 <titledesc> Pedestal distribution for ACD PMTA range Low</titledesc>
	 <axisdesc> [Pedestal (ADC counts), N] </axisdesc>
	 <description> Pedestal distribution for ACD PMTA range Low. Only periodic triggers with NOT-Zero supressed are taken into account.</description>
      </object>

       <object>
	<name> ACD_Ped_PMTB_LowRange_TH1_AcdTile[128]</name>
	 <formula><![CDATA[AcdPha_PmtIdPmtRangeAcdTile[1][0]]]></formula>
	 <cut><![CDATA[ condsummary==32 && (!ZeroSuppress)]]></cut>
	 <type> histogram-1d[1001,0,1001, -1] </type>
	 <titledesc> Pedestal distribution for ACD PMTB range Low</titledesc>
	 <axisdesc> [Pedestal (ADC counts), N] </axisdesc>
	 <description> Pedestal distribution for ACD PMTB range Low. Only periodic triggers with NOT-Zero supressed are taken into account.</description>
      </object>




       <object>
       <name> ACD_PedMean_PMTA_LowRange_TH1</name>
	<formula><![CDATA[Mean_AcdPedestal_PmtA_LowPMTRange_AcdTile]]></formula>
	<cut><![CDATA[]]></cut>
	<source>output</source>
	<type> histogram-vecdim-1d[128,-0.5,127.5,0] </type>
	<titledesc> Pedestal mean vs GEM tile number for PMTA range LOW </titledesc>
	<axisdesc> [Gem tile number, Ped Mean (ADC counts)] </axisdesc>
	<description> Pedestal mean (ADC counts) vs GEM tile number for PMTA range LOW. Only Periodic triggers with non-zerosuppress are considered.  </description>
       </object>


       <object>
       <name> ACD_PedRMS_PMTA_LowRange_TH1</name>
	<formula><![CDATA[foreachacdtile: Mean_AcdPedestal_PmtA_LowPMTRange_AcdTile_err[acdtile]*TMath::Sqrt(Mean_AcdPedestal_PmtA_LowPMTRange_AcdTile_n[acdtile])]]></formula>
	<cut><![CDATA[]]></cut>
	<source>output</source>
	<type> histogram-vecdim-1d[128,-0.5,127.5,0] </type>
	<titledesc> Pedestal RMS vs GEM tile number for PMTA range LOW </titledesc>
	<axisdesc> [Gem tile number, Ped RMS (ADC counts)] </axisdesc>
	<description> Pedestal RMS (ADC counts) vs GEM tile number for PMTA range LOW. Only Periodic triggers with non-zerosuppress are considered.  </description>
       </object>


        <object>
       <name> ACD_PedMean_PMTB_LowRange_TH1</name>
	<formula><![CDATA[Mean_AcdPedestal_PmtB_LowPMTRange_AcdTile]]></formula>
	<cut><![CDATA[]]></cut>
	<source>output</source>
	<type> histogram-vecdim-1d[128,-0.5,127.5,0] </type>
	<titledesc> Pedestal mean vs GEM tile number for PMTB range LOW </titledesc>
	<axisdesc> [Gem tile number, Ped Mean (ADC counts)] </axisdesc>
	<description> Pedestal mean (ADC counts) vs GEM tile number for PMTB range LOW. Only Periodic triggers with non-zerosuppress are considered.  </description>
       </object>

	 <object>
       <name> ACD_PedRMS_PMTB_LowRange_TH1</name>
	<formula><![CDATA[foreachacdtile: Mean_AcdPedestal_PmtB_LowPMTRange_AcdTile_err[acdtile]*TMath::Sqrt(Mean_AcdPedestal_PmtB_LowPMTRange_AcdTile_n[acdtile])]]></formula>
	<cut><![CDATA[]]></cut>
	<source>output</source>
	<type> histogram-vecdim-1d[128,-0.5,127.5,0] </type>
	<titledesc> Pedestal RMS vs GEM tile number for PMTB range LOW </titledesc>
	<axisdesc> [Gem tile number, Ped RMS (ADC counts)] </axisdesc>
	<description> Pedestal RMS (ADC counts) vs GEM tile number for PMTB range LOW. Only Periodic triggers with non-zerosuppress are considered.  </description>
       </object>


	 <object>
      <name> AcdPmt_OverThreshold_Asymmetry_AcdTile_TH1 </name>
      <formula><![CDATA[ foreachacdtile: Counter_AnyAcdPmt_OverThreshold_AcdTile[acdtile] > 0 ? (double(Counter_AcdPmtA_OverThreshold_AcdTile[acdtile])-double(Counter_AcdPmtB_OverThreshold_AcdTile[acdtile]))/double(Counter_AnyAcdPmt_OverThreshold_AcdTile[acdtile]) : 2.0 ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <source>output</source>
      <type> histogram-vecdim-1d[128,-0.5,127.5,2] </type>
      <titledesc> A-B PMT over threshold asymmetry   </titledesc>
      <axisdesc> [Tile number, A-B asymmetry] </axisdesc>
      <description> A-B PMT over threshold asymmetry. The asymmetry is defined as A-B/(A OR B). </description>
    </object>


   
       <object>
      <name> AcdPmt_Veto_Asymmetry_AcdTile_TH1 </name>
      <formula><![CDATA[ foreachacdtile: Counter_AnyAcdVeto_AcdTile[acdtile] > 0 ? (double(Counter_AcdVetoA_AcdTile[acdtile])-double(Counter_AcdVetoB_AcdTile[acdtile]))/double(Counter_AnyAcdVeto_AcdTile[acdtile]) : 2.0 ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <source>output</source>
      <type> histogram-vecdim-1d[128,-0.5,127.5,2] </type>
      <titledesc> A-B PMT Veto asymmetry   </titledesc>
      <axisdesc> [Tile number, A-B asymmetry] </axisdesc>
      <description> A-B PMT veto asymmetry. The asymmetry is defined as A-B/(A OR B). </description>
    </object>




      <!-- Calorimeter -->


        <object>
	 <name> CalXAdcPed_TH1_TowerCalLayerCalColumnFR[16][8][12][2][4]</name>
	 <formula><![CDATA[CalXAdc_TowerCalLayerCalColumnFaceRange]]></formula>
	 <cut><![CDATA[ condsummary==32 && Range4 && (!ZeroSuppress)  && (DeltaEventTime>2000)]]></cut>
	 <type> histogram-1d[1002,-1,1001] </type>
	 <titledesc> Pedestal distribution</titledesc>
	 <axisdesc> [Pedestal (ADC counts), N] </axisdesc>
	 <description> Pedestal distribution. Only periodic triggers with 4-range readout and NOT-Zero supressed are taken into account.</description>
      </object>



     <object>
       <name> CalXAdcPedMean_LEX8_TH1</name>
	<formula><![CDATA[Mean_CalXAdc_LEX8_TowerCalLayerCalColumnF]]></formula>
	<cut><![CDATA[]]></cut>
	<source>output</source>
	<type> histogram-vecdim-1d[3072,-0.5,3071.5,-1] </type>
	<titledesc> Pedestal mean vs channel number for range LEX8 </titledesc>
	<axisdesc> [Channel number, Ped Mean (ADC counts)] </axisdesc>
	<description> Pedestal mean (ADC counts) vs channel number (=tower*8*12*2+layer*12*2+column*2+face) for range LEX8. Only Periodic triggers with 4 range readout and non-zerosuppress are considered.  </description>
      </object>

     <object>
       <name> CalXAdcPedRMS_LEX8_TH1</name>
	<formula><![CDATA[ foreachtower: foreachcallayer: foreachcalcolumn: foreachcalxface: Mean_CalXAdc_LEX8_TowerCalLayerCalColumnF_err[tower][callayer][calcolumn][calxface]*TMath::Sqrt(Mean_CalXAdc_LEX8_TowerCalLayerCalColumnF_n[tower][callayer][calcolumn][calxface])]]></formula>
	<cut><![CDATA[]]></cut>
	<source>output</source>
	<type> histogram-vecdim-1d[3072,-0.5,3071.5,-1] </type>
	<titledesc> Pedestal RMS vs channel number for range LEX8 </titledesc>
	<axisdesc> [Channel number, Ped RMS (ADC counts)] </axisdesc>
	<description> Pedestal RMS (ADC counts) vs channel number (=tower*8*12*2+layer*12*2+column*2+face) for range LEX8. Only Periodic triggers with 4 range readout and non-zerosuppress are considered. </description>
      </object>

      <object>
       <name> CalXAdcPedMean_LEX1_TH1</name>
	<formula><![CDATA[Mean_CalXAdc_LEX1_TowerCalLayerCalColumnF]]></formula>
	<cut><![CDATA[]]></cut>
	<source>output</source>
	<type> histogram-vecdim-1d[3072,-0.5,3071.5,-1] </type>
	<titledesc> Pedestal mean vs channel number for range LEX1 </titledesc>
	<axisdesc> [Channel number, Ped Mean (ADC counts)] </axisdesc>
	<description> Pedestal mean (ADC counts) vs channel number (=tower*8*12*2+layer*12*2+column*2+face) for range LEX1. Only Periodic triggers with 4 range readout and non-zerosuppress are considered.  </description>
      </object>

     <object>
       <name> CalXAdcPedRMS_LEX1_TH1</name>
	<formula><![CDATA[ foreachtower: foreachcallayer: foreachcalcolumn: foreachcalxface: Mean_CalXAdc_LEX1_TowerCalLayerCalColumnF_err[tower][callayer][calcolumn][calxface]*TMath::Sqrt(Mean_CalXAdc_LEX1_TowerCalLayerCalColumnF_n[tower][callayer][calcolumn][calxface])]]></formula>
	<cut><![CDATA[]]></cut>
	<source>output</source>
	<type> histogram-vecdim-1d[3072,-0.5,3071.5,-1] </type>
	<titledesc> Pedestal RMS vs channel number for range LEX1 </titledesc>
	<axisdesc> [Channel number, Ped RMS (ADC counts)] </axisdesc>
	<description> Pedestal RMS (ADC counts) vs channel number (=tower*8*12*2+layer*12*2+column*2+face) for range LEX1. Only Periodic triggers with 4 range readout and non-zerosuppress are considered. </description>
      </object>
	

       <object>
        <name> CalXAdcPedMean_HEX8_TH1</name>
	<formula><![CDATA[Mean_CalXAdc_HEX8_TowerCalLayerCalColumnF]]></formula>
	<cut><![CDATA[]]></cut>
	<source>output</source>
	<type> histogram-vecdim-1d[3072,-0.5,3071.5,-1] </type>
	<titledesc> Pedestal mean vs channel number for range HEX8 </titledesc>
	<axisdesc> [Channel number, Ped Mean (ADC counts)] </axisdesc>
	<description> Pedestal mean (ADC counts) vs channel number (=tower*8*12*2+layer*12*2+column*2+face) for range HEX8. Only Periodic triggers with 4 range readout and non-zerosuppress are considered.  </description>
      </object>

     <object>
        <name> CalXAdcPedRMS_HEX8_TH1</name>
	<formula><![CDATA[ foreachtower: foreachcallayer: foreachcalcolumn: foreachcalxface: Mean_CalXAdc_HEX8_TowerCalLayerCalColumnF_err[tower][callayer][calcolumn][calxface]*TMath::Sqrt(Mean_CalXAdc_HEX8_TowerCalLayerCalColumnF_n[tower][callayer][calcolumn][calxface])]]></formula>
	<cut><![CDATA[]]></cut>
	<source>output</source>
	<type> histogram-vecdim-1d[3072,-0.5,3071.5,-1] </type>
	<titledesc> Pedestal RMS vs channel number for range HEX8 </titledesc>
	<axisdesc> [Channel number, Ped RMS (ADC counts)] </axisdesc>
	<description> Pedestal RMS (ADC counts) vs channel number (=tower*8*12*2+layer*12*2+column*2+face) for range HEX8. Only Periodic triggers with 4 range readout and non-zerosuppress are considered. </description>
      </object>

      <object>
       <name> CalXAdcPedMean_HEX1_TH1</name>
	<formula><![CDATA[Mean_CalXAdc_HEX1_TowerCalLayerCalColumnF]]></formula>
	<cut><![CDATA[]]></cut>
	<source>output</source>
	<type> histogram-vecdim-1d[3072,-0.5,3071.5,-1] </type>
	<titledesc> Pedestal mean vs channel number for range HEX1 </titledesc>
	<axisdesc> [Channel number, Ped Mean (ADC counts)] </axisdesc>
	<description> Pedestal mean (ADC counts) vs channel number (=tower*8*12*2+layer*12*2+column*2+face) for range HEX1. Only Periodic triggers with 4 range readout and non-zerosuppress are considered.  </description>
      </object>

     <object>
        <name> CalXAdcPedRMS_HEX1_TH1</name>
	<formula><![CDATA[ foreachtower: foreachcallayer: foreachcalcolumn: foreachcalxface: Mean_CalXAdc_HEX1_TowerCalLayerCalColumnF_err[tower][callayer][calcolumn][calxface]*TMath::Sqrt(Mean_CalXAdc_HEX1_TowerCalLayerCalColumnF_n[tower][callayer][calcolumn][calxface])]]></formula>
	<cut><![CDATA[]]></cut>
	<source>output</source>
	<type> histogram-vecdim-1d[3072,-0.5,3071.5,-1] </type>
	<titledesc> Pedestal RMS vs channel number for range HEX1 </titledesc>
	<axisdesc> [Channel number, Ped RMS (ADC counts)] </axisdesc>
	<description> Pedestal RMS (ADC counts) vs channel number (=tower*8*12*2+layer*12*2+column*2+face) for range HEX1. Only Periodic triggers with 4 range readout and non-zerosuppress are considered. </description>
      </object>
	


    
   
     <object>
        <name> CalXPedDev_Mean_TH1</name>
	<formula><![CDATA[ Mean_CalXPedDev_TowerCalLayerCalColumnFR ]]></formula>
	<cut><![CDATA[]]></cut>
	<source>output</source>
	<type> histogram-vecdim-1d[12288,-0.5,12287.5,-1] </type>
	<titledesc> Pedestal Deviations Mean vs channel number </titledesc>
	<axisdesc> [Channel number, Ped Deviation Mean (ADC counts)] </axisdesc>
	<description> Mean pedestal deviations, versus channel number (=tower*8*12*2*4+layer*12*2*4+column*2*4+face*4+range), between the measured pedestals and the ones retrieved from the data base. The mean is computed removing (truncating) 10 percent of the events located at each of the sides (beginning+end) of the distribution of values; that is with the 80 percent central values. Only periodic triggers with 4 range readout and non-zerosuppress events are being used. </description>
      </object>

     <object>
        <name> CalXPedDev_RMS_TH1</name>
	<formula><![CDATA[ foreachtower: foreachcallayer: foreachcalcolumn: foreachcalxface: foreachcalxrange: Mean_CalXPedDev_TowerCalLayerCalColumnFR_err[tower][callayer][calcolumn][calxface][calxrange]*TMath::Sqrt(Mean_CalXPedDev_TowerCalLayerCalColumnFR_n[tower][callayer][calcolumn][calxface][calxrange])]]></formula>
	<cut><![CDATA[]]></cut>
	<source>output</source>
	<type> histogram-vecdim-1d[12288,-0.5,12287.5,-1] </type>
	<titledesc> Pedestal Deviations RMS vs channel number </titledesc>
	<axisdesc> [Channel number, Ped Deviation RMS (ADC counts)] </axisdesc>
	<description> RMS in the distribution of the pedestal deviations, versus channel number (=tower*8*12*2*4+layer*12*2*4+column*2*4+face*4+range), between the measured pedestals and the ones retrieved from the data base. The RMS is computed removing (truncating) 10 percent of the events located at each of the sides (beginning+end) of the distribution of values; that is with the 80 percent central values. Only periodic triggers with 4 range readout and non-zerosuppress events are being used. </description>
      </object>


     <object>
        <name> RPM_Mean_TH1</name>
	<formula><![CDATA[ Mean_RPM_TowerCalLayerCalColumn ]]></formula>
	<cut><![CDATA[]]></cut>
	<source>output</source>
	<type> histogram-vecdim-1d[1536,-0.5,1535.5,-1] </type>
	<titledesc> Mean of relative gain LEX1(plus face) / LEX1(minus face)  vs channel number </titledesc>
	<axisdesc> [Channel number, Mean of PM ratio] </axisdesc>
	<description> Mean of ratio LEX1(plus face) / LEX1(minus face) = P/M versus channel number (=tower*8*12+layer*12+column). This ratio is expected to be close to 1. Pedestals (extracted from data base) are subtracted before computing the ratio. For each channel, the mean is computed excluding the tails up to a fraction of 0.1 on each side in order to remove outliers; that is with the 80 percent of central values. Only 4 range readout events which are NOT periodic triggers are being used. A minimum signal (after pedestal subtraction) of 50 ADC counts is required.  </description>
      </object>

     <object>
        <name> RPM_RMS_TH1</name>
	<formula><![CDATA[ foreachtower: foreachcallayer: foreachcalcolumn: Mean_RPM_TowerCalLayerCalColumn_err[tower][callayer][calcolumn]*TMath::Sqrt(Mean_RPM_TowerCalLayerCalColumn_n[tower][callayer][calcolumn])]]></formula>
	<cut><![CDATA[]]></cut>
	<source>output</source>
	<type> histogram-vecdim-1d[1536,-0.5,1535.5,-1]  </type>
	<titledesc> RMS of relative gain LEX1(plus face) / LEX1(minus face)  vs channel number </titledesc>
	<axisdesc> [Channel number, RMS of PM ratio] </axisdesc>
	<description> RMS of ratio LEX1(plus face) / LEX1(minus face) = P/M versus channel number (=tower*8*12+layer*12+column). Pedestals (extracted from data base) are subtracted before computing the ratio. For each channel, the RMS is computed excluding the tails up to a fraction of 0.1 on each side in order to remove outliers; that is with the 80 percent of central values. Only 4 range readout events which are NOT periodic triggers are being used. A minimum signal (after pedestal subtraction) of 50 ADC counts is required.  </description>
      </object>
  




      <object>
        <name> RPp_Mean_TH1</name>
	<formula><![CDATA[ Mean_RPp_TowerCalLayerCalColumn ]]></formula>
	<cut><![CDATA[]]></cut>
	<source>output</source>
	<type> histogram-vecdim-1d[1536,-0.5,1535.5,-1] </type>
	<titledesc> Mean of relative gain LEX1(plus face) / HEX8(plus face)  vs channel number </titledesc>
	<axisdesc> [Channel number, Mean of Pp ratio] </axisdesc>
	<description> Mean of ratio LEX1(plus face) / HEX8(plus face) = P/p versus channel number (=tower*8*12+layer*12+column). This ratio is expected to be close to 6 (for flight gains). Pedestals (extracted from data base) are subtracted before computing the ratio. For each channel, the mean is computed excluding the tails up to a fraction of 0.1 on each side in order to remove outliers; that is with the 80 percent of central values. Only 4 range readout events which are NOT periodic triggers are being used. A minimum signal (after pedestal subtraction) of 50 ADC counts is required.  </description>
      </object>

     <object>
        <name> RPp_RMS_TH1</name>
	<formula><![CDATA[ foreachtower: foreachcallayer: foreachcalcolumn: Mean_RPp_TowerCalLayerCalColumn_err[tower][callayer][calcolumn]*TMath::Sqrt(Mean_RPp_TowerCalLayerCalColumn_n[tower][callayer][calcolumn])]]></formula>
	<cut><![CDATA[]]></cut>
	<source>output</source>
	<type> histogram-vecdim-1d[1536,-0.5,1535.5,-1]  </type>
	<titledesc> RMS of relative gain LEX1(plus face) / HEX8(plus face)   vs channel number </titledesc>
	<axisdesc> [Channel number, RMS of Pp ratio] </axisdesc>
	<description> RMS of ratio LEX1(plus face) / HEX8(plus face)  = P/p versus channel number (=tower*8*12+layer*12+column). Pedestals (extracted from data base) are subtracted before computing the ratio. For each channel, the RMS is computed excluding the tails up to a fraction of 0.1 on each side in order to remove outliers; that is with the 80 percent of central values. Only 4 range readout events which are NOT periodic triggers are being used. A minimum signal (after pedestal subtraction) of 50 ADC counts is required.  </description>
      </object>



  <object>
	<name> RMm_Mean_TH1</name>
	<formula><![CDATA[ Mean_RMm_TowerCalLayerCalColumn ]]></formula>
	<cut><![CDATA[]]></cut>
	<source>output</source>
	<type> histogram-vecdim-1d[1536,-0.5,1535.5,-1] </type>
	<titledesc> Mean of relative gain LEX1(minus face) / HEX8(minus face)  vs channel number </titledesc>
	<axisdesc> [Channel number, Mean of Mm ratio] </axisdesc>
	<description> Mean of ratio LEX1(minus face) / HEX8(minus face) = M/m versus channel number (=tower*8*12+layer*12+column). This ratio is expected to be close to 6 (for flight gains). Pedestals (extracted from data base) are subtracted before computing the ratio. For each channel, the mean is computed excluding the tails up to a fraction of 0.1 on each side in order to remove outliers; that is with the 80 percent of central values. Only 4 range readout events which are NOT periodic triggers are being used. A minimum signal (after pedestal subtraction) of 50 ADC counts is required.  </description>
      </object>

     <object>
	<name> RMm_RMS_TH1</name>
	<formula><![CDATA[ foreachtower: foreachcallayer: foreachcalcolumn: Mean_RMm_TowerCalLayerCalColumn_err[tower][callayer][calcolumn]*TMath::Sqrt(Mean_RMm_TowerCalLayerCalColumn_n[tower][callayer][calcolumn])]]></formula>
	<cut><![CDATA[]]></cut>
	<source>output</source>
	<type> histogram-vecdim-1d[1536,-0.5,1535.5,-1]  </type>
	<titledesc> RMS of relative gain LEX1(minus face) / HEX8(minus face)   vs channel number </titledesc>
	<axisdesc> [Channel number, RMS of Mm ratio] </axisdesc>
	<description> RMS of ratio LEX1(minus face) / HEX8(minus face)  = M/m versus channel number (=tower*8*12+layer*12+column). Pedestals (extracted from data base) are subtracted before computing the ratio. For each channel, the RMS is computed excluding the tails up to a fraction of 0.1 on each side in order to remove outliers; that is with the 80 percent of central values. Only 4 range readout events which are NOT periodic triggers are being used. A minimum signal (after pedestal subtraction) of 50 ADC counts is required.  </description>
      </object>


           <object>
      <name> RPM_TH1_TowerCalLayerCalColumn[16][8][12] </name>
      <formula><![CDATA[foreachtower:foreachcallayer:foreachcalcolumn: RFun::computeratio(CalXAdc_TowerCalLayerCalColumnFaceRange[tower][callayer][calcolumn][0][1],RFun::calped(timestamp,tower,callayer,calcolumn,0,1), CalXAdc_TowerCalLayerCalColumnFaceRange[tower][callayer][calcolumn][1][1], RFun::calped(timestamp,tower,callayer,calcolumn,1,1), 50)]]></formula>
      <cut><![CDATA[!(condsummary&32) && Range4]]></cut>
      <type> histogram-1d[1000,0,5,-1] </type>
      <description> Distribution of the ratio LEX1(plus face) / LEX1(minus face) = P/M. This ratio is expected to be close to 1. Pedestals (extracted from data base) are subtracted before computing the ratio. Only 4 range readout events which are NOT periodic triggers are being used. A minimum signal (after pedestal subtraction) of 50 ADC counts is required. </description>
    </object>


      <object>
      <name> RPp_TH1_TowerCalLayerCalColumn[16][8][12] </name>
      <formula><![CDATA[foreachtower:foreachcallayer:foreachcalcolumn: RFun::computeratio_v2(CalXAdc_TowerCalLayerCalColumnFaceRange[tower][callayer][calcolumn][0][1],RFun::calped(timestamp,tower,callayer,calcolumn,0,1), 500, CalXAdc_TowerCalLayerCalColumnFaceRange[tower][callayer][calcolumn][0][2], RFun::calped(timestamp,tower,callayer,calcolumn,0,2), 50)]]></formula>
      <cut><![CDATA[!(condsummary&32) && Range4]]></cut>
      <type> histogram-1d[5000,0,25,-1] </type>
      <description> Distribution of the ratio LEX1(plus face) / HEX8 (plus face) = P/p. This ratio is expected to be close to 6. Pedestals (extracted from data base) are subtracted before computing the ratio.  Only 4 range readout events which are NOT periodic triggers are being used. A minimum signal (after pedestal subtraction) of 50 ADC counts is required. </description>
    </object>

       <object>
      <name> RMm_TH1_TowerCalLayerCalColumn[16][8][12] </name>
      <formula><![CDATA[foreachtower:foreachcallayer:foreachcalcolumn: RFun::computeratio_v2(CalXAdc_TowerCalLayerCalColumnFaceRange[tower][callayer][calcolumn][1][1],RFun::calped(timestamp,tower,callayer,calcolumn,1,1), 500, CalXAdc_TowerCalLayerCalColumnFaceRange[tower][callayer][calcolumn][1][2], RFun::calped(timestamp,tower,callayer,calcolumn,1,2), 50)]]></formula>
      <cut><![CDATA[!(condsummary&32) && Range4]]></cut>
      <type> histogram-1d[5000,0,25,-1]  </type>
      <description> Distribution of the ratio LEX1(minus face) / HEX8(minus face) = M/m. This ratio is expected to be close to 6. Pedestals (extracted from data base) are subtracted before computing the ratio. Only 4 range readout events which are NOT periodic triggers are being used. A minimum signal (after pedestal subtraction) of 50 ADC counts is required. </description>
    </object>
      
     



  </outputList>

  <eventCut><![CDATA[ ]]></eventCut>
  <timestamp> timestampdouble </timestamp>
</monitoring>
