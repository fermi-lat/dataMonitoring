<monitoring>
  <inputList name="top"> 

    <!-- TEST variables -->
    <object> nACD </object>
    <object> Gem_elapsed </object>
    
    <!-- Time stamp -->
    <object> timestampdouble </object>
    <object> timestamp </object> <!-- some functions need time stamp as int -->
    <object> DataTransferId </object>
    
    <!-- Event classification information -->
    <object> condsummary </object>
    <object> condarrcallo  </object>
    <object> condarrcalhi </object>
    <object> condarrtkr </object>
    <object> condarrcno </object>
    <object> condarrroi </object>
    <object> LivetimeLast</object>
    <object> ElapsedLast</object>
    <object> DeadZoneLast</object>
    <object> DiscardedLast</object>
    <object> PrescaledLast</object>
    <object> DeadZoneDelta </object>
    <object> DiscardedDelta </object>
    <object> PrescaledDelta </object>
    <object> DeltaWindowOpen </object>
    <object> DeltaEventTime </object>
    <object> TkrTriggerTower </object>
    <object> CalHiTriggerTower </object> 
    <object> CalLoTriggerTower </object>
    <object> CalReadoutRange </object>
    <object> Range4 </object>
    <object> OBFStatus </object>
    <object> Sequence </object>
    <object> FilterBits </object>
     <object> TriggerEngine </object>
    <object> DeltaEventTimeManual </object> 
    <object> DatagramInfo </object>
    <object> DeltaEvtID </object>
    <object> Delta_CCSDSTime_EvtTime </object>
    <object> NewSecond </object>
    <object>sourceGps </object>
    <object>FswFilters</object>
    <object>FswFiltersLeaked</object>
    <object>GemPrescale</object>
    <object>DGNGemPrescale</object>
    <object>FswFilters_GammaBits</object>
    <object>EventSizeInBytes</object>
    <object>MootKey</object>
    <object>CondSummary5bits</object>
    <object>L1TTriggerWord5bits</object>
    <object>FswGAMMAEnergyInLeus</object>
    <object>CompressedEventSizeInBytes </object>
    <object>CompressionLevel </object>

    <!-- Acd Variables -->
    
    <object>AcdGemVeto_AcdTile</object>
    <object>AcdGemROI_Tower </object>
    <object>AcdGemCNO_GARC  </object>
    <object>AcdHit_AcdTile  </object>
    <object>AcdSingleHit </object>
    <object>AcdPmtA_OverThreshold_AcdTile  </object>
    <object>AcdPmtB_OverThreshold_AcdTile  </object>
    <object>AcdVetoA_AcdTile  </object>
    <object>AcdVetoB_AcdTile  </object>
    <object>AcdVetoA_OR_B_AcdTile </object>
    <object>AcdSingleVeto_AcdTile </object>
    <object>AcdPha_PmtIdPmtRangeAcdTile</object>
    <object>AcdHit_GafeGarc </object>
    <object>AcdVeto_GafeGarc </object>

    <!-- Tkr Variables -->
       
    <object> TkrHitsTowerPlane </object>
    <object> IsTkrDigi_TowerPlane </object>
    <object> ToT_con0_TowerPlane  </object>
    <object> ToT_con1_TowerPlane  </object>

     <!-- Cal Variables -->
    <object> CalXHit_TowerCalLayerCalColumn </object>
    <object> CalXHit_TowerCalLayer </object>
    <object> CalXAdc_TowerCalLayerCalColumnFaceRange </object>
    
  </inputList>


  <outputList name="top">
  

   

    <!-- ********************  Event classification information   *********************** -->
          
    

    <object>
      <name> LastDataTransferId </name>
      <formula><![CDATA[ DataTransferId ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <type> valuechange[0] </type>
      <description> Data transfer id within the time bin. The first, last and the number of chnages are stored for each time bin.   </description>
    </object>

     <object>
      <name> MootKey </name>
      <formula><![CDATA[ MootKey ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <type> valuechange[0] </type>
      <description> Moot Key within the time bin. The first, last and the number of chnages are stored for each time bin.   </description>
    </object>

     <object>
      <name> Trigger_CALLO </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[condsummary&4  ]]></cut>
      <type> rate </type>
      <description> CAL-LO trigger rate </description>
    </object>

 
    

     <object>
      <name> Trigger_CALHI </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[condsummary&8  ]]></cut>
      <type> rate </type>
      <description> CAL-HI trigger rate </description>
    </object>

      <object>
      <name> Trigger_CNO </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[condsummary&16  ]]></cut>
      <type> rate </type>
      <description> CNO trigger rate </description>
    </object>

       <object>
      <name> Trigger_TKR </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[condsummary&2]]></cut>
      <type> rate </type>
      <description> TKR trigger rate </description>
    </object>

     
       <object>
      <name> Trigger_ROI </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[condsummary&1]]></cut>
      <type> rate </type>
      <description> ROI trigger rate </description>
    </object>


     <object>
      <name> Trigger_TKR_And_ROI </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[(condsummary&1) && (condsummary&2)]]></cut>
      <type> rate </type>
      <description> Rate of TKR trigger and ROI (mostly charge particles) </description>
    </object>

     <object>
      <name> Trigger_TKR_And_NotROI </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[!(condsummary&1) && (condsummary&2)]]></cut>
      <type> rate </type>
      <description> Rate TKR trigger and not ROI (mostly non charge particles) rate </description>
    </object>

     <object>
      <name> Trigger_Periodic </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[condsummary&32]]></cut>
      <type> rate </type>
      <description> Periodic trigger rate </description>
    </object>

     <object>
      <name> Trigger_PeriodicEqual32 </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[condsummary==32]]></cut>
      <type> rate </type>
      <description> Periodic trigger rate in which condsummary is equal to 32</description>
    </object>

     <object>
      <name> Trigger_NOTPeriodic </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[!(condsummary&32)]]></cut>
      <type> rate </type>
      <description> Rate of events with NOT periodic trigger  </description>
    </object>

    

     <object>
      <name> CondsummaryBitAnd30_NOTPeriodic </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[condsummary&30 && !(condsummary&32)]]></cut>
      <type> counter </type>
      <description> Counter of events with condsummaryBitAnd30 AND NotcondsummaryBitAnd32) </description>
    </object>


     <object>
      <name> Trigger_Solicited </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[condsummary&64]]></cut>
      <type> rate </type>
      <description> Solicited trigger rate </description>
    </object>

     <object>
      <name> Trigger_External </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[condsummary&128]]></cut>
      <type> rate </type>
      <description> External trigger rate </description>
    </object>

     <object>
      <name> Trigger_ANY </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[condsummary&255]]></cut>
      <type> rate </type>
      <description> Rate of any of the trigger bits in condsummary word </description>
    </object>

     <object>
      <name> Trigger_ANYPhysics </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[condsummary&15]]></cut>
      <type> rate </type>
      <description> Rate of any non-artificially created trigger (i.e. bits [1-4]) in condsummary word  </description>
    </object>
      
       <object>
      <name> TkrTrigger_Tower[16] </name>
      <formula><![CDATA[ foreachtower: TkrTriggerTower[tower] ]]></formula>
      <cut><![CDATA[ !(condsummary&32)]]></cut>
      <type> rate </type>
      <description> Rate of tracker triggers in [tower], calculated during the specified time bin. Periodic triggers are not taken into account.</description>
    </object>

       <object>
      <name> OBF_GAMMAFilter </name>
      <formula><![CDATA[ OBFStatus[0] ]]></formula>
      <cut><![CDATA[ OBFStatus[0]>0 ]]></cut>
      <type> rate </type>
      <description> Rate of evts passing the onboard gamma filter, calculated during the specified time bin. </description>
    </object>

	  <object>
      <name> OBF_MIPFilter </name>
      <formula><![CDATA[ OBFStatus[1] ]]></formula>
      <cut><![CDATA[ OBFStatus[1]>0 ]]></cut>
      <type> rate </type>
      <description> Rate of evts passing the onboard Mip filter, calculated during the specified time bin. </description>
    </object>


	    <object>
      <name> OBF_HIPFilter </name>
      <formula><![CDATA[ OBFStatus[2] ]]></formula>
      <cut><![CDATA[ OBFStatus[2]>0 ]]></cut>
      <type> rate </type>
      <description> Rate of evts passing the onboard HIP filter, calculated during the specified time bin. </description>
    </object>

	    <object>
      <name> OBF_DGNFilter </name>
      <formula><![CDATA[ OBFStatus[3] ]]></formula>
      <cut><![CDATA[OBFStatus[3]>0 ]]></cut>
      <type> rate </type>
      <description> Rate of evts passing the onboard DGN filter, calculated during the specified time bin. </description>
    </object>

      <object>
      <name> ComputationFailed_OBF_GAMMAFilter </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[ OBFStatus[0]<0 ]]></cut>
      <type> rate </type>
      <description> Rate of evts for which the Gamma Filter could not be computed. </description>
    </object>

	  <object>
      <name> ComputationFailed_OBF_MIPFilter </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[ OBFStatus[1]<0 ]]></cut>
      <type> rate </type>
      <description> Rate of evts for which the Mip Filter  could not be computed. </description>
    </object>


	    <object>
      <name> ComputationFailed_OBF_HIPFilter </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[ OBFStatus[2]<0 ]]></cut>
      <type> rate </type>
      <description> Rate of evts for which the HIP Filter  could not be computed. </description>
    </object>

	    <object>
      <name> ComputationFailed_OBF_DGNFilter </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[OBFStatus[3]<0 ]]></cut>
      <type> rate </type>
      <description> Rate of evts for which the DGN Filter  could not be computed.</description>
    </object>


       
     <object>
      <name> GemRate </name>
      <formula><![CDATA[ Sequence ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <type> counterdiffrate[10000,17,MC] </type>
      <description> Rate of evts before any filter (computed using DigiEvent->getMetaEvent().scalers().sequence().) </description>
    </object>

     <!-- The cut FilterBits[0]>0 is to ensure that the filter bits were computed
	  If computation could not be done, then all components are set 
	  to -1 in FilterBits vector -->
      <object>
      <name> GammaFilterBit[32] </name>
      <formula><![CDATA[ FilterBits ]]></formula>
      <cut><![CDATA[ FilterBits[0]>0]]></cut>
      <type> rate </type>
      <description> Vector [32] storing the rate of evts passing the 32 Gamma filters. </description>
    </object>

       <object>
      <name> GammaFilterBit_ComputationFailed </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[ FilterBits[0]<0]]></cut>
      <type> rate </type>
      <description> Rate of evts for which the GammaFilterBits could not be computed. </description>
    </object>
     
       <object>
      <name> Deadzone </name>
      <formula><![CDATA[ DeadZoneDelta ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <type> rate </type>
      <description> Rate of GEM deadzone events </description>
    </object>

         <object>
      <name> Discarded </name>
      <formula><![CDATA[ DiscardedDelta ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <type> rate </type>
      <description> Rate of GEM discarded events </description>
    </object>

    <object>
      <name> Prescaled </name>
      <formula><![CDATA[ PrescaledDelta  ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <type> rate </type>
      <description> Rate of GEM prescaled events </description>
    </object>

     
    <object>
      <name> Trigger_CALLO_And_GammaFilter </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[(condsummary&4)  && (OBFStatus[0]>0)]]></cut>
      <type> rate </type>
      <description> Rate of events with CAL-LO trigger AND GammaFilter </description>
    </object>


     <object>
      <name> Trigger_CALHI_And_GammaFilter </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[(condsummary&8) && (OBFStatus[0]>0)  ]]></cut>
      <type> rate </type>
      <description> Rate of events with CAL-HI trigger AND GammaFilter  </description>
    </object>

      <object>
      <name> Trigger_CNO_And_GammaFilter </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[(condsummary&16) && (OBFStatus[0]>0)  ]]></cut>
      <type> rate </type>
      <description> Rate of events with CNO  trigger AND GammaFilter  </description>
    </object>

       <object>
      <name> Trigger_TKR_And_GammaFilter </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[(condsummary&2) && (OBFStatus[0]>0)]]></cut>
      <type> rate </type>
      <description> Rate of events with TKR trigger AND GammaFilter  </description>
    </object>

         <object>
      <name> Trigger_ROI_And_GammaFilter </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[(condsummary&1) &&  (OBFStatus[0]>0)]]></cut>
      <type> rate </type>
      <description> Rate of events with ROI trigger AND GammaFilter  </description>
    </object>


     <object>
      <name> Trigger_TKR_And_ROI_And_GammaFilter </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[(condsummary&1) && (condsummary&2) && (OBFStatus[0]>0)]]></cut>
      <type> rate </type>
      <description> Rate of TKR trigger and ROI (mostly charge particles) AND GammaFilter. We expect to have very low rates of events fulfilling those somewhat contradictory requirements.</description>
    </object>

     <object>
      <name> Trigger_TKR_And_NotROI_And_GammaFilter </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[!(condsummary&1) && (condsummary&2) && (OBFStatus[0]>0)]]></cut>
      <type> rate </type>
      <description> Rate of TKR trigger and not ROI (mostly non charge particles) AND GammaFilter. We expect to have essentially the same rate as without the GammaFilter. </description>
    </object>


     <object>
      <name> Trigger_CALLO_And_OneOfOther3Filters </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[(condsummary&4)  && (OBFStatus[1]>0 || OBFStatus[2]>0 || OBFStatus[2]>0)]]></cut>
      <type> rate </type>
      <description> Rate of events with CAL-LO trigger AND ANY of the following Filters: Mip OR HIP OR DGN.  </description>
    </object>


     <object>
      <name> Trigger_CALHI_And_OneOfOther3Filters </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[(condsummary&8) && (OBFStatus[1]>0 || OBFStatus[2]>0 || OBFStatus[2]>0)  ]]></cut>
      <type> rate </type>
      <description> Rate of events with CAL-HI trigger AND ANY of the following Filters: Mip OR HIP OR DGN.  </description>
    </object>

      <object>
      <name> Trigger_CNO_And_OneOfOther3Filters </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[(condsummary&16) && (OBFStatus[1]>0 || OBFStatus[2]>0 || OBFStatus[2]>0)  ]]></cut>
      <type> rate </type>
      <description> Rate of events with CNO trigger AND ANY of the following Filters: Mip OR HIP OR DGN.  </description>
    </object>

       <object>
      <name> Trigger_TKR_And_OneOfOther3Filters </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[(condsummary&2) && (OBFStatus[1]>0 || OBFStatus[2]>0 || OBFStatus[2]>0)]]></cut>
      <type> rate </type>
      <description> Rate of events with TKR trigger AND ANY of the following Filters: Mip OR HIP OR DGN.  </description>
    </object>

           <object>
      <name> Trigger_ROI_And_OneOfOther3Filters </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[(condsummary&1) && (OBFStatus[1]>0 || OBFStatus[2]>0 || OBFStatus[2]>0)]]></cut>
      <type> rate </type>
      <description> Rate of events with ROI trigger AND ANY of the following Filters: Mip OR HIP OR DGN.  </description>
    </object>


     <object>
      <name> Trigger_TKR_And_ROI_And_OneOfOther3Filters </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[(condsummary&1) && (condsummary&2) && (OBFStatus[1]>0 || OBFStatus[2]>0 || OBFStatus[2]>0)]]></cut>
      <type> rate </type>
      <description> Rate of TKR trigger and ROI (mostly charged particles) AND ANY of the following Filters: Mip OR HIP OR DGN. </description>
    </object>

     <object>
      <name> Trigger_TKR_And_NotROI_And_OneOfOther3Filters </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[!(condsummary&1) && (condsummary&2) && (OBFStatus[1]>0 || OBFStatus[2]>0 || OBFStatus[2]>0)]]></cut>
      <type> rate </type>
      <description> Rate TKR trigger and not ROI (mostly non charge particles) AND ANY of the following Filters: Mip OR HIP OR DGN. </description>
    </object>


      <object>
      <name> TriggerEngine[16] </name>
      <formula><![CDATA[ TriggerEngine ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <type> rate </type>
      <description> Rate of Trigger Engines (DigiEvent->getL1T().getGemEngine()) </description>
    </object>

       <object>
      <name> UnPrescaled_TriggerEngine[16] </name>
      <formula><![CDATA[ foreachengine: TriggerEngine[engine]*DGNGemPrescale ]]></formula>
      <cut><![CDATA[FswFilters[3]>0 ]]></cut>
      <type> rate </type>
      <description> UnPrescaled Rate of Trigger Engines surviving the DGN filter; that is the rate of trigger engine (DigiEvent->getL1T().getGemEngine()) surviving the Fsw DGN filter and corrected for the prescaled (DGNxGEM) factor </description>
    </object>
      
       <object>
      <name> CalHiTrigger_Tower[16] </name>
      <formula><![CDATA[ CalHiTriggerTower ]]></formula>
      <cut><![CDATA[!(condsummary&32)]]></cut>
      <type> rate </type>
      <description> Rate of CAL HI Triggers per tower. Periodic triggers are not taken into account. </description>
    </object>

         <object>
      <name> CalLoTrigger_Tower[16] </name>
      <formula><![CDATA[ CalLoTriggerTower ]]></formula>
      <cut><![CDATA[ !(condsummary&32)]]></cut>
      <type> rate </type>
      <description> Rate of CAL Lo Triggers per tower. Periodic triggers are not taken into account. </description>
    </object>

 	 <object>
	   <name> LiveTimeFraction </name>
	   <formula><![CDATA[ LivetimeLast]]></formula>
	   <cut><![CDATA[condsummary&30]]></cut>
	   <type> doublediffrate[MC] </type>
	   <description> Fraction of livetime (in percent) per time interval </description>
	 </object>
	 
	 <object>
	   <name> TriggerRate_ANYPhysics_LiveTimeCorrected </name>
	   <formula><![CDATA[foronetime: DoubleDiffRate_LiveTimeFraction>0 ? (Double_t(Rate_Trigger_ANYPhysics*100.)/DoubleDiffRate_LiveTimeFraction) : 0.0]]></formula>
	   <cut><![CDATA[ ]]></cut>
	   <source>output</source>
	   <type> outputfloat </type>
	   <description> Rate of any non-artificially created trigger (i.e. bits [1-4]) in condsummary word, corrected for the livetime.  </description>
	 </object>
	 
<!--	 Error of livetime is NOT taken into account, since that cannot be computed -->
	 <object>
	   <name> TriggerRate_ANYPhysics_LiveTimeCorrected_err </name>
	   <formula><![CDATA[ foronetime: DoubleDiffRate_LiveTimeFraction>0 ? (Double_t(Rate_Trigger_ANYPhysics_err*100)/DoubleDiffRate_LiveTimeFraction) : 0.0]]></formula>
	   <cut><![CDATA[ ]]></cut>
	   <source>output</source>
	   <type> outputfloat </type>
	   <description> Error in Rate of any non-artificially created trigger (i.e. bits [1-4]) in condsummary word, corrected for the livetime.   </description>
	 </object>

    <object>
      <name> GPS_OUTofLock </name>
      <formula><![CDATA[ !sourceGps ]]></formula>
      <cut><![CDATA[ NewSecond&1]]></cut>
      <type> rate </type>
      <description> Rate of number of seconds in which the GPS is out of lock. This rate should be ZERO, meaning that GPS is always in lock.  </description>
    </object>

     <object>
      <name> NewSecond </name>
      <formula><![CDATA[ NewSecond ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <type> rate </type>
      <description> Rate of 'NewSecond'; where 'NewSecond' is a variable set to 1 when current time (in units of seconds) is different to previous' evt time. The variable is 0 otherwise. The time is extracted as digi->getMetaEvent().time().current().timeSecs(). </description>
    </object>

     
	<object>
      <name> NormalizedRate_GPS_OUTofLock </name>
      <formula><![CDATA[ foronetime: (Rate_NewSecond>0) ? Rate_GPS_OUTofLock/Rate_NewSecond: -1.0 ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <source> output </source>
      <type> outputfloat </type>
      <description> Normalized Rate of number of seconds in which the GPS is out of lock. This rate should be ZERO, meaning that GPS is always in lock. The normalization factor is Rate_NewSecond, that is the rate of time tones. </description>
    </object>	      

 

    <object><!-- Error in number of events is Sqrt(N*fraction*(1-fraction), which is expected from binomial distribution -->
      <!-- Then the error needs to be normalized with the number of new seconds; pow(Rate_NewSecond/Rate_NewSecond_err,2) -->
      <name> NormalizedRate_GPS_OUTofLock_err </name> 
      <formula><![CDATA[ foronetime: (Rate_NewSecond>0 && Rate_NewSecond_err>0) ? TMath::Sqrt(pow(Rate_NewSecond/Rate_NewSecond_err,2)*(Rate_GPS_OUTofLock/Rate_NewSecond)*(1-(Rate_GPS_OUTofLock/Rate_NewSecond)))/pow(Rate_NewSecond/Rate_NewSecond_err,2) : 0.0 ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <source> output </source>
      <type> outputfloat </type>
      <description> Error in the normalized Rate of number of seconds in which the GPS is out of lock. This rate should be ZERO, meaning that GPS is always in lock. The normalization factor is Rate_NewSecond, that is the rate of time tones. </description>
    </object>	    


  
     <object>
      <name> FswGAMMAEnergyInLeus </name>
      <formula><![CDATA[ FswGAMMAEnergyInLeus[0] ]]></formula>
      <cut><![CDATA[ FswGAMMAEnergyInLeus[1]>0.5]]></cut>
      <type> mean </type>
      <description> Mean FswGAMMA energy in Leus. Only events with valid energy (getEnergyValid()>0) are used. </description>
    </object>

     <object>
      <name> EventSizeInBytes </name>
      <formula><![CDATA[ EventSizeInBytes ]]></formula>
      <cut><![CDATA[ EventSizeInBytes>1]]></cut>
      <type> truncatedmean[0.5,100000000] </type>
      <description> Mean Size of the Event (bytes) during the specified time interval. </description>
    </object>

     <object>
      <name> EvtSizeInBytes </name>
      <formula><![CDATA[ EventSizeInBytes ]]></formula>
      <cut><![CDATA[ EventSizeInBytes>1]]></cut>
      <type> rate </type>
      <description> Rate of  Bytes (Evt size before compression) during the specified time interval. </description>
    </object>

       <object>
      <name> EventSizeInBytes_TriggerEngine[16] </name>
      <formula><![CDATA[ foreachengine: TriggerEngine[engine]*double(EventSizeInBytes) ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <type> truncatedmean[0.5,100000000] </type>
      <description> Mean Size of the Event (bytes) for each GEM Trigger Engine, calculated during the specified time interval. </description>
    </object>


    <object>
      <name> CompressionLevel </name>
      <formula><![CDATA[ CompressionLevel ]]></formula>
      <cut><![CDATA[]]></cut>
      <type> mean </type>
      <description> Mean compression level (m_digiEvent->getMetaEvent().compressionLevel()) </description>
    </object>

    <object>
      <name> CompressedEvtSizeInBytes </name>
      <formula><![CDATA[ CompressedEventSizeInBytes ]]></formula>
      <cut><![CDATA[ CompressedEventSizeInBytes>1]]></cut>
      <type> rate </type>
      <description> Rate of  Bytes (Evt size AFTER compression) during the specified time interval. </description>
    </object>

   

    <object>
      <name> Ratio_EvtSize_CompressedEvtSize </name>
      <formula><![CDATA[ Rate_EvtSizeInBytes/Rate_CompressedEvtSizeInBytes ]]></formula>
      <cut><![CDATA[ Rate_CompressedEvtSizeInBytes!=0]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Ratio EvtSizeInBytes/CompressedEvtSizeInBytes </description>
    </object>


    <object>
      <name> Ratio_EvtSize_CompressedEvtSize_err </name>
      <formula><![CDATA[ 0.0 ]]></formula>
      <cut><![CDATA[ Rate_CompressedEvtSizeInBytes!=0 ]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description>Error in Ratio_EvtSize_CompressedEvtSize </description>
    </object>


    <object>
      <name> CompressedEvtSizeInBytes_FswGAMMA </name>
      <formula><![CDATA[ CompressedEventSizeInBytes ]]></formula>
      <cut><![CDATA[ CompressedEventSizeInBytes>1 && FswFilters[0]>0 && FswFiltersLeaked[0]>0]]></cut>
      <type> rate </type>
      <description> Rate of  bytes (size AFTER compression) during the specified time interval for evts surviving the Fsw GAMMA filter. This is the bandwidth that we need to download those evts. </description>
    </object>

     <object>
      <name> CompressedEvtSizeInBytes_FswMIP </name>
      <formula><![CDATA[ CompressedEventSizeInBytes ]]></formula>
      <cut><![CDATA[ CompressedEventSizeInBytes>1 && FswFilters[1]>0 && FswFiltersLeaked[1]>0]]></cut>
      <type> rate </type>
      <description> Rate of  bytes (size AFTER compression) during the specified time interval for evts surviving the Fsw MIP filter. This is the bandwidth that we need to download those evts. </description>
    </object>

    <object>
      <name> CompressedEvtSizeInBytes_FswHIP </name>
      <formula><![CDATA[ CompressedEventSizeInBytes ]]></formula>
      <cut><![CDATA[ CompressedEventSizeInBytes>1 && FswFilters[2]>0 && FswFiltersLeaked[2]>0]]></cut>
      <type> rate </type>
      <description> Rate of  bytes (size AFTER compression) during the specified time interval for evts surviving the Fsw HIP filter. This is the bandwidth that we need to download those evts. </description>
    </object>

     <object>
      <name> CompressedEvtSizeInBytes_FswDGN </name>
      <formula><![CDATA[ CompressedEventSizeInBytes ]]></formula>
      <cut><![CDATA[ CompressedEventSizeInBytes>1 && FswFilters[3]>0 && FswFiltersLeaked[3]>0]]></cut>
      <type> rate </type>
      <description> Rate of  bytes (size AFTER compression) during the specified time interval for evts surviving the Fsw DGN filter. This is the bandwidth that we need to download those evts. </description>
    </object>
    

	      <!-- Trigger Rates per tower geometry -->

    <object>
      <name> CornerTower_TkrTrigger </name>
      <formula><![CDATA[ TkrTriggerTower[0] || TkrTriggerTower[3] || TkrTriggerTower[12] || TkrTriggerTower[15]]]></formula>
      <cut><![CDATA[ !(condsummary&32)]]></cut>
      <type> rate </type>
      <description> Rate of TKR Triggers occurring in the CORNER towers. Periodic triggers are not taken into account. </description>
    </object>

    <object>
      <name> CenterTower_TkrTrigger </name>
      <formula><![CDATA[ TkrTriggerTower[5] || TkrTriggerTower[6] || TkrTriggerTower[9] || TkrTriggerTower[10]]]></formula>
      <cut><![CDATA[ !(condsummary&32)]]></cut>
      <type> rate </type>
      <description> Rate of TKR Triggers occurring in the CENTER towers. Periodic triggers are not taken into account. </description>
    </object>


    <object>
      <name> PlusXTower_TkrTrigger </name>
      <formula><![CDATA[ TkrTriggerTower[3] || TkrTriggerTower[7] || TkrTriggerTower[11] || TkrTriggerTower[15]]]></formula>
      <cut><![CDATA[ !(condsummary&32)]]></cut>
      <type> rate </type>
      <description> Rate of TKR Triggers occurring in the PlusX towers. Periodic triggers are not taken into account. </description>
    </object>

    <object>
      <name> MinusXTower_TkrTrigger </name>
      <formula><![CDATA[ TkrTriggerTower[0] || TkrTriggerTower[4] || TkrTriggerTower[8] || TkrTriggerTower[12]]]></formula>
      <cut><![CDATA[ !(condsummary&32)]]></cut>
      <type> rate </type>
      <description> Rate of TKR Triggers occurring in the MinusX towers. Periodic triggers are not taken into account. </description>
    </object>


    <object>
      <name> PlusYTower_TkrTrigger </name>
      <formula><![CDATA[ TkrTriggerTower[12] || TkrTriggerTower[13] || TkrTriggerTower[14] || TkrTriggerTower[15]]]></formula>
      <cut><![CDATA[ !(condsummary&32)]]></cut>
      <type> rate </type>
      <description> Rate of TKR Triggers occurring in the PlusY towers. Periodic triggers are not taken into account. </description>
    </object>

    <object>
      <name> MinusYTower_TkrTrigger </name>
      <formula><![CDATA[ TkrTriggerTower[0] || TkrTriggerTower[1] || TkrTriggerTower[2] || TkrTriggerTower[3]]]></formula>
      <cut><![CDATA[ !(condsummary&32)]]></cut>
      <type> rate </type>
      <description> Rate of TKR Triggers occurring in the MinusY towers. Periodic triggers are not taken into account. </description>
    </object>


    <object>
      <name> CornerTower_CalLoTrigger </name>
      <formula><![CDATA[ CalLoTriggerTower[0] || CalLoTriggerTower[3] || CalLoTriggerTower[12] || CalLoTriggerTower[15]]]></formula>
      <cut><![CDATA[ !(condsummary&32)]]></cut>
      <type> rate </type>
      <description> Rate of CAL Lo Triggers occurring in the CORNER towers. Periodic triggers are not taken into account. </description>
    </object>

    <object>
      <name> CenterTower_CalLoTrigger </name>
      <formula><![CDATA[ CalLoTriggerTower[5] || CalLoTriggerTower[6] || CalLoTriggerTower[9] || CalLoTriggerTower[10]]]></formula>
      <cut><![CDATA[ !(condsummary&32)]]></cut>
      <type> rate </type>
      <description> Rate of CAL Lo Triggers occurring in the CENTER towers. Periodic triggers are not taken into account. </description>
    </object>


    <object>
      <name> PlusXTower_CalLoTrigger </name>
      <formula><![CDATA[ CalLoTriggerTower[3] || CalLoTriggerTower[7] || CalLoTriggerTower[11] || CalLoTriggerTower[15]]]></formula>
      <cut><![CDATA[ !(condsummary&32)]]></cut>
      <type> rate </type>
      <description> Rate of CAL Lo Triggers occurring in the PlusX towers. Periodic triggers are not taken into account. </description>
    </object>

    <object>
      <name> MinusXTower_CalLoTrigger </name>
      <formula><![CDATA[ CalLoTriggerTower[0] || CalLoTriggerTower[4] || CalLoTriggerTower[8] || CalLoTriggerTower[12]]]></formula>
      <cut><![CDATA[ !(condsummary&32)]]></cut>
      <type> rate </type>
      <description> Rate of CAL Lo Triggers occurring in the MinusX towers. Periodic triggers are not taken into account. </description>
    </object>


    <object>
      <name> PlusYTower_CalLoTrigger </name>
      <formula><![CDATA[ CalLoTriggerTower[12] || CalLoTriggerTower[13] || CalLoTriggerTower[14] || CalLoTriggerTower[15]]]></formula>
      <cut><![CDATA[ !(condsummary&32)]]></cut>
      <type> rate </type>
      <description> Rate of CAL Lo Triggers occurring in the PlusY towers. Periodic triggers are not taken into account. </description>
    </object>

    <object>
      <name> MinusYTower_CalLoTrigger </name>
      <formula><![CDATA[ CalLoTriggerTower[0] || CalLoTriggerTower[1] || CalLoTriggerTower[2] || CalLoTriggerTower[3]]]></formula>
      <cut><![CDATA[ !(condsummary&32)]]></cut>
      <type> rate </type>
      <description> Rate of CAL Lo Triggers occurring in the MinusY towers. Periodic triggers are not taken into account. </description>
    </object>



    <object>
      <name> CornerTower_CalHiTrigger </name>
      <formula><![CDATA[ CalHiTriggerTower[0] || CalHiTriggerTower[3] || CalHiTriggerTower[12] || CalHiTriggerTower[15]]]></formula>
      <cut><![CDATA[ !(condsummary&32)]]></cut>
      <type> rate </type>
      <description> Rate of CAL Hi Triggers occurring in the CORNER towers. Periodic triggers are not taken into account. </description>
    </object>

    <object>
      <name> CenterTower_CalHiTrigger </name>
      <formula><![CDATA[ CalHiTriggerTower[5] || CalHiTriggerTower[6] || CalHiTriggerTower[9] || CalHiTriggerTower[10]]]></formula>
      <cut><![CDATA[ !(condsummary&32)]]></cut>
      <type> rate </type>
      <description> Rate of CAL Hi Triggers occurring in the CENTER towers. Periodic triggers are not taken into account. </description>
    </object>


    <object>
      <name> PlusXTower_CalHiTrigger </name>
      <formula><![CDATA[ CalHiTriggerTower[3] || CalHiTriggerTower[7] || CalHiTriggerTower[11] || CalHiTriggerTower[15]]]></formula>
      <cut><![CDATA[ !(condsummary&32)]]></cut>
      <type> rate </type>
      <description> Rate of CAL Hi Triggers occurring in the PlusX towers. Periodic triggers are not taken into account. </description>
    </object>

    <object>
      <name> MinusXTower_CalHiTrigger </name>
      <formula><![CDATA[ CalHiTriggerTower[0] || CalHiTriggerTower[4] || CalHiTriggerTower[8] || CalHiTriggerTower[12]]]></formula>
      <cut><![CDATA[ !(condsummary&32)]]></cut>
      <type> rate </type>
      <description> Rate of CAL Hi Triggers occurring in the MinusX towers. Periodic triggers are not taken into account. </description>
    </object>


    <object>
      <name> PlusYTower_CalHiTrigger </name>
      <formula><![CDATA[ CalHiTriggerTower[12] || CalHiTriggerTower[13] || CalHiTriggerTower[14] || CalHiTriggerTower[15]]]></formula>
      <cut><![CDATA[ !(condsummary&32)]]></cut>
      <type> rate </type>
      <description> Rate of CAL Hi Triggers occurring in the PlusY towers. Periodic triggers are not taken into account. </description>
    </object>

    <object>
      <name> MinusYTower_CalHiTrigger </name>
      <formula><![CDATA[ CalHiTriggerTower[0] || CalHiTriggerTower[1] || CalHiTriggerTower[2] || CalHiTriggerTower[3]]]></formula>
      <cut><![CDATA[ !(condsummary&32)]]></cut>
      <type> rate </type>
      <description> Rate of CAL Hi Triggers occurring in the MinusY towers. Periodic triggers are not taken into account. </description>
    </object>

   
     <object>
      <name> UnPrescaled_CornerTower_TkrTrigger </name>
      <formula><![CDATA[ (TkrTriggerTower[0] || TkrTriggerTower[3] || TkrTriggerTower[12] || TkrTriggerTower[15])*DGNGemPrescale ]]></formula>
      <cut><![CDATA[ !(condsummary&32) && FswFilters[3]>0]]></cut>
      <type> rate </type>
      <description> Unprescaled and unbiased (DGN filter set) rate of TKR Triggers occurring in the CORNER towers. Periodic triggers are not taken into account. </description>
    </object>

    <object>
      <name> UnPrescaled_CenterTower_TkrTrigger </name>
      <formula><![CDATA[ (TkrTriggerTower[5] || TkrTriggerTower[6] || TkrTriggerTower[9] || TkrTriggerTower[10])*DGNGemPrescale]]></formula>
      <cut><![CDATA[ !(condsummary&32) && FswFilters[3]>0]]></cut>
      <type> rate </type>
      <description> Unprescaled and unbiased (DGN filter set) rate of TKR Triggers occurring in the CENTER towers. Periodic triggers are not taken into account. </description>
    </object>


    <object>
      <name> UnPrescaled_PlusXTower_TkrTrigger </name>
      <formula><![CDATA[ (TkrTriggerTower[3] || TkrTriggerTower[7] || TkrTriggerTower[11] || TkrTriggerTower[15])*DGNGemPrescale]]></formula>
      <cut><![CDATA[ !(condsummary&32) && FswFilters[3]>0]]></cut>
      <type> rate </type>
      <description> Unprescaled and unbiased (DGN filter set) rate of TKR Triggers occurring in the PlusX towers. Periodic triggers are not taken into account. </description>
    </object>

    <object>
      <name> UnPrescaled_MinusXTower_TkrTrigger </name>
      <formula><![CDATA[ (TkrTriggerTower[0] || TkrTriggerTower[4] || TkrTriggerTower[8] || TkrTriggerTower[12])*DGNGemPrescale]]></formula>
      <cut><![CDATA[ !(condsummary&32) && FswFilters[3]>0]]></cut>
      <type> rate </type>
      <description> Unprescaled and unbiased (DGN filter set) rate of TKR Triggers occurring in the MinusX towers. Periodic triggers are not taken into account. </description>
    </object>


    <object>
      <name> UnPrescaled_PlusYTower_TkrTrigger </name>
      <formula><![CDATA[ (TkrTriggerTower[12] || TkrTriggerTower[13] || TkrTriggerTower[14] || TkrTriggerTower[15])*DGNGemPrescale]]></formula>
      <cut><![CDATA[ !(condsummary&32) && FswFilters[3]>0]]></cut>
      <type> rate </type>
      <description> Unprescaled and unbiased (DGN filter set) rate of TKR Triggers occurring in the PlusY towers. Periodic triggers are not taken into account. </description>
    </object>

    <object>
      <name> UnPrescaled_MinusYTower_TkrTrigger </name>
      <formula><![CDATA[ (TkrTriggerTower[0] || TkrTriggerTower[1] || TkrTriggerTower[2] || TkrTriggerTower[3])*DGNGemPrescale]]></formula>
      <cut><![CDATA[ !(condsummary&32) && FswFilters[3]>0]]></cut>
      <type> rate </type>
      <description> Unprescaled and unbiased (DGN filter set) rate of TKR Triggers occurring in the MinusY towers. Periodic triggers are not taken into account. </description>
    </object>


    <object>
      <name> UnPrescaled_CornerTower_CalLoTrigger </name>
      <formula><![CDATA[ (CalLoTriggerTower[0] || CalLoTriggerTower[3] || CalLoTriggerTower[12] || CalLoTriggerTower[15])*DGNGemPrescale]]></formula>
      <cut><![CDATA[ !(condsummary&32) && FswFilters[3]>0]]></cut>
      <type> rate </type>
      <description> Unprescaled and unbiased (DGN filter set) rate of CAL Lo Triggers occurring in the CORNER towers. Periodic triggers are not taken into account. </description>
    </object>

    <object>
      <name> UnPrescaled_CenterTower_CalLoTrigger </name>
      <formula><![CDATA[ (CalLoTriggerTower[5] || CalLoTriggerTower[6] || CalLoTriggerTower[9] || CalLoTriggerTower[10])*DGNGemPrescale]]></formula>
      <cut><![CDATA[ !(condsummary&32) && FswFilters[3]>0]]></cut>
      <type> rate </type>
      <description> Unprescaled and unbiased (DGN filter set) rate of CAL Lo Triggers occurring in the CENTER towers. Periodic triggers are not taken into account. </description>
    </object>


    <object>
      <name> UnPrescaled_PlusXTower_CalLoTrigger </name>
      <formula><![CDATA[ (CalLoTriggerTower[3] || CalLoTriggerTower[7] || CalLoTriggerTower[11] || CalLoTriggerTower[15])*DGNGemPrescale]]></formula>
      <cut><![CDATA[ !(condsummary&32) && FswFilters[3]>0]]></cut>
      <type> rate </type>
      <description> Unprescaled and unbiased (DGN filter set) rate of CAL Lo Triggers occurring in the PlusX towers. Periodic triggers are not taken into account. </description>
    </object>

    <object>
      <name> UnPrescaled_MinusXTower_CalLoTrigger </name>
      <formula><![CDATA[ (CalLoTriggerTower[0] || CalLoTriggerTower[4] || CalLoTriggerTower[8] || CalLoTriggerTower[12])*DGNGemPrescale]]></formula>
      <cut><![CDATA[ !(condsummary&32) && FswFilters[3]>0]]></cut>
      <type> rate </type>
      <description> Unprescaled and unbiased (DGN filter set) rate of CAL Lo Triggers occurring in the MinusX towers. Periodic triggers are not taken into account. </description>
    </object>


    <object>
      <name> UnPrescaled_PlusYTower_CalLoTrigger </name>
      <formula><![CDATA[ (CalLoTriggerTower[12] || CalLoTriggerTower[13] || CalLoTriggerTower[14] || CalLoTriggerTower[15])*DGNGemPrescale]]></formula>
      <cut><![CDATA[ !(condsummary&32) && FswFilters[3]>0]]></cut>
      <type> rate </type>
      <description> Unprescaled and unbiased (DGN filter set) rate of CAL Lo Triggers occurring in the PlusY towers. Periodic triggers are not taken into account. </description>
    </object>

    <object>
      <name> UnPrescaled_MinusYTower_CalLoTrigger </name>
      <formula><![CDATA[ (CalLoTriggerTower[0] || CalLoTriggerTower[1] || CalLoTriggerTower[2] || CalLoTriggerTower[3])*DGNGemPrescale]]></formula>
      <cut><![CDATA[ !(condsummary&32) && FswFilters[3]>0]]></cut>
      <type> rate </type>
      <description> Unprescaled and unbiased (DGN filter set) rate of CAL Lo Triggers occurring in the MinusY towers. Periodic triggers are not taken into account. </description>
    </object>



    <object>
      <name> UnPrescaled_CornerTower_CalHiTrigger </name>
      <formula><![CDATA[ (CalHiTriggerTower[0] || CalHiTriggerTower[3] || CalHiTriggerTower[12] || CalHiTriggerTower[15])*DGNGemPrescale]]></formula>
      <cut><![CDATA[ !(condsummary&32) && FswFilters[3]>0]]></cut>
      <type> rate </type>
      <description> Unprescaled and unbiased (DGN filter set) rate of CAL Hi Triggers occurring in the CORNER towers. Periodic triggers are not taken into account. </description>
    </object>

    <object>
      <name> UnPrescaled_CenterTower_CalHiTrigger </name>
      <formula><![CDATA[ (CalHiTriggerTower[5] || CalHiTriggerTower[6] || CalHiTriggerTower[9] || CalHiTriggerTower[10])*DGNGemPrescale]]></formula>
      <cut><![CDATA[ !(condsummary&32) && FswFilters[3]>0]]></cut>
      <type> rate </type>
      <description> Unprescaled and unbiased (DGN filter set) rate of CAL Hi Triggers occurring in the CENTER towers. Periodic triggers are not taken into account. </description>
    </object>


    <object>
      <name> UnPrescaled_PlusXTower_CalHiTrigger </name>
      <formula><![CDATA[ (CalHiTriggerTower[3] || CalHiTriggerTower[7] || CalHiTriggerTower[11] || CalHiTriggerTower[15])*DGNGemPrescale]]></formula>
      <cut><![CDATA[ !(condsummary&32) && FswFilters[3]>0]]></cut>
      <type> rate </type>
      <description> Unprescaled and unbiased (DGN filter set) rate of CAL Hi Triggers occurring in the PlusX towers. Periodic triggers are not taken into account. </description>
    </object>

    <object>
      <name> UnPrescaled_MinusXTower_CalHiTrigger </name>
      <formula><![CDATA[ (CalHiTriggerTower[0] || CalHiTriggerTower[4] || CalHiTriggerTower[8] || CalHiTriggerTower[12])*DGNGemPrescale]]></formula>
      <cut><![CDATA[ !(condsummary&32) && FswFilters[3]>0]]></cut>
      <type> rate </type>
      <description> Unprescaled and unbiased (DGN filter set) rate of CAL Hi Triggers occurring in the MinusX towers. Periodic triggers are not taken into account. </description>
    </object>


    <object>
      <name> UnPrescaled_PlusYTower_CalHiTrigger </name>
      <formula><![CDATA[ (CalHiTriggerTower[12] || CalHiTriggerTower[13] || CalHiTriggerTower[14] || CalHiTriggerTower[15])*DGNGemPrescale]]></formula>
      <cut><![CDATA[ !(condsummary&32) && FswFilters[3]>0]]></cut>
      <type> rate </type>
      <description> Unprescaled and unbiased (DGN filter set) rate of CAL Hi Triggers occurring in the PlusY towers. Periodic triggers are not taken into account. </description>
    </object>

    <object>
      <name> UnPrescaled_MinusYTower_CalHiTrigger </name>
      <formula><![CDATA[ (CalHiTriggerTower[0] || CalHiTriggerTower[1] || CalHiTriggerTower[2] || CalHiTriggerTower[3])*DGNGemPrescale]]></formula>
      <cut><![CDATA[ !(condsummary&32) && FswFilters[3]>0]]></cut>
      <type> rate </type>
      <description> Unprescaled and unbiased (DGN filter set) rate of CAL Hi Triggers occurring in the MinusY towers. Periodic triggers are not taken into account. </description>
    </object>

   
    <!-- Rate of triggers using the Real Flight Sowftware Onboard trigger bits -->

     <object>
      <name> FswFilters_GAMMA </name>
      <formula><![CDATA[ FswFilters[0] ]]></formula>
      <cut><![CDATA[ FswFilters[0]>0 ]]></cut>
      <type> rate </type>
      <description> Rate of evts passing the REAL flight software onboard GAMMA filter, calculated during the specified time bin. </description>
    </object>

    <object>
      <name> FswFilters_GAMMA_Leaked </name>
      <formula><![CDATA[ FswFiltersLeaked[0] ]]></formula>
      <cut><![CDATA[ FswFiltersLeaked[0]>0 ]]></cut>
      <type> rate </type>
      <description> Rate of evts that LEAKED the REAL flight software onboard GAMMA filter, calculated during the specified time bin. </description>
    </object>


     <object>
      <name> FswFilters_MIP </name>
      <formula><![CDATA[ FswFilters[1] ]]></formula>
      <cut><![CDATA[ FswFilters[1]>0 ]]></cut>
      <type> rate </type>
      <description> Rate of evts passing the REAL flight software onboard MIP filter, calculated during the specified time bin. </description>
    </object>

     <object>
      <name> FswFilters_HIP </name>
      <formula><![CDATA[ FswFilters[2] ]]></formula>
      <cut><![CDATA[ FswFilters[2]>0 ]]></cut>
      <type> rate </type>
      <description> Rate of evts passing the REAL flight software onboard HIP filter, calculated during the specified time bin. </description>
    </object>


     <object>
      <name> FswFilters_DGN </name>
      <formula><![CDATA[ FswFilters[3] ]]></formula>
      <cut><![CDATA[ FswFilters[3]>0 ]]></cut>
      <type> rate </type>
      <description> Rate of evts passing the REAL flight software onboard DGN filter, calculated during the specified time bin. </description>
    </object>


     <object>
      <name> UnPrescaled_FswFilters_DGN </name>
      <formula><![CDATA[ DGNGemPrescale ]]></formula>
      <cut><![CDATA[ FswFilters[3]>0 ]]></cut>
      <type> rate </type>
      <description> Rate of evts passing the REAL flight software onboard DGN filter UnPrescaled according to the engine number, calculated during the specified time bin. </description>
    </object>

     

      <object>
      <name> FswFilters_PassThru </name>
      <formula><![CDATA[ FswFilters[4] ]]></formula>
      <cut><![CDATA[ FswFilters[4]>0]]></cut>
      <type> rate </type>
      <description> Rate of evts passing the REAL flight software onboard PassThru filter, calculated during the specified time bin.  </description>
    </object>



     <object>
      <name> FswFilters_GAMMA_And_HIP </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[ (FswFilters[0]>0) && (FswFilters[2]>0) ]]></cut>
      <type> rate </type>
      <description> Rate of evts passing the REAL flight software onboard GAMMA AND HIP filters, calculated during the specified time bin. </description>
    </object>


      <!-- The cut FswFilters_GammaBits[0]>0 is to ensure that the filter bits were computed
	  If computation could not be done, then all components are set 
	  to -1 in FswFilters_GammaBits vector -->
     <object>
      <name> FswFilters_GammaFilterBit[32] </name>
      <formula><![CDATA[ FswFilters_GammaBits ]]></formula>
      <cut><![CDATA[ FswFilters_GammaBits[0]>0]]></cut>
      <type> rate </type>
      <description> Vector [32] storing the rate of evts passing the 32 Gamma filters. </description>
    </object>


     <!-- DGN, Gamma, Hip, Mip  filter simultaneous to others -->

      <object>
      <name> FswDGN_AND_Trigger_CALLO </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[FswFilters[3]>0 && condsummary&4  ]]></cut>
      <type> rate </type>
      <description> CAL-LO trigger rate passing the DGN Flight Software onboard filter</description>
    </object>


     <object>
      <name> FswDGN_AND_Trigger_CALHI </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[FswFilters[3]>0 && condsummary&8  ]]></cut>
      <type> rate </type>
      <description> CAL-HI trigger rate passing the DGN Flight Software onboard filter</description>
    </object>

      <object>
      <name> FswDGN_AND_Trigger_CNO </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[FswFilters[3]>0 && condsummary&16  ]]></cut>
      <type> rate </type>
      <description> CNO trigger rate passing the DGN Flight Software onboard filter</description>
    </object>

       <object>
      <name> FswDGN_AND_Trigger_TKR </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[FswFilters[3]>0 && condsummary&2]]></cut>
      <type> rate </type>
      <description> TKR trigger rate passing the DGN Flight Software onboard filter</description>
    </object>

       <object>
      <name> FswDGN_AND_Trigger_ROI </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[FswFilters[3]>0 && condsummary&1]]></cut>
      <type> rate </type>
      <description> ROI trigger rate passing the DGN Flight Software onboard filter</description>
    </object>

        <object>
      <name> FswDGN_AND_TriggerEngine[16] </name>
      <formula><![CDATA[TriggerEngine ]]></formula>
      <cut><![CDATA[FswFilters[3]>0 ]]></cut>
      <type> rate </type>
      <description> Rate of Trigger Engines (DigiEvent->getL1T().getGemEngine()) passing the DGN Flight Software onboard filter</description>
    </object>

     <object>
      <name> UnPrescaled_FswDGN_AND_Trigger_CALLO </name>
      <formula><![CDATA[ DGNGemPrescale ]]></formula>
      <cut><![CDATA[FswFilters[3]>0 && condsummary&4  ]]></cut>
      <type> rate </type>
      <description> UnPrescaled CAL-LO trigger rate passing the DGN Flight Software onboard filter</description>
    </object>


     <object>
      <name> UnPrescaled_FswDGN_AND_Trigger_CALHI </name>
      <formula><![CDATA[ DGNGemPrescale ]]></formula>
      <cut><![CDATA[FswFilters[3]>0 && condsummary&8  ]]></cut>
      <type> rate </type>
      <description> UnPrescaled CAL-HI trigger rate passing the DGN Flight Software onboard filter</description>
    </object>

      <object>
      <name> UnPrescaled_FswDGN_AND_Trigger_CNO </name>
      <formula><![CDATA[ DGNGemPrescale ]]></formula>
      <cut><![CDATA[FswFilters[3]>0 && condsummary&16  ]]></cut>
      <type> rate </type>
      <description> UnPrescaled CNO trigger rate passing the DGN Flight Software onboard filter</description>
    </object>

       <object>
      <name> UnPrescaled_FswDGN_AND_Trigger_TKR </name>
      <formula><![CDATA[ DGNGemPrescale ]]></formula>
      <cut><![CDATA[FswFilters[3]>0 && condsummary&2]]></cut>
      <type> rate </type>
      <description> UnPrescaled TKR trigger rate passing the DGN Flight Software onboard filter</description>
    </object>

       <object>
      <name> UnPrescaled_FswDGN_AND_Trigger_ROI </name>
      <formula><![CDATA[ DGNGemPrescale ]]></formula>
      <cut><![CDATA[FswFilters[3]>0 && condsummary&1]]></cut>
      <type> rate </type>
      <description> UnPrescaled ROI trigger rate passing the DGN Flight Software onboard filter</description>
    </object>

	


	

		 <object>
      <name> FswGAMMA_AND_Trigger_CALLO </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[FswFilters[0]>0 && condsummary&4  ]]></cut>
      <type> rate </type>
      <description> CAL-LO trigger rate passing the GAMMA Flight Software onboard filter</description>
    </object>


     <object>
      <name> FswGAMMA_AND_Trigger_CALHI </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[FswFilters[0]>0 && condsummary&8  ]]></cut>
      <type> rate </type>
      <description> CAL-HI trigger rate passing the GAMMA Flight Software onboard filter</description>
    </object>

      <object>
      <name> FswGAMMA_AND_Trigger_CNO </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[FswFilters[0]>0 && condsummary&16  ]]></cut>
      <type> rate </type>
      <description> CNO trigger rate passing the GAMMA Flight Software onboard filter</description>
    </object>

       <object>
      <name> FswGAMMA_AND_Trigger_TKR </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[FswFilters[0]>0 && condsummary&2]]></cut>
      <type> rate </type>
      <description> TKR trigger rate passing the GAMMA Flight Software onboard filter</description>
    </object>

       <object>
      <name> FswGAMMA_AND_Trigger_ROI </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[FswFilters[0]>0 && condsummary&1]]></cut>
      <type> rate </type>
      <description> ROI trigger rate passing the GAMMA Flight Software onboard filter</description>
    </object>


       	 <object>
      <name> FswHIP_AND_Trigger_CALLO </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[FswFilters[2]>0 && condsummary&4  ]]></cut>
      <type> rate </type>
      <description> CAL-LO trigger rate passing the HIP Flight Software onboard filter</description>
    </object>


     <object>
      <name> FswHIP_AND_Trigger_CALHI </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[FswFilters[2]>0 && condsummary&8  ]]></cut>
      <type> rate </type>
      <description> CAL-HI trigger rate passing the HIP Flight Software onboard filter</description>
    </object>

      <object>
      <name> FswHIP_AND_Trigger_CNO </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[FswFilters[2]>0 && condsummary&16  ]]></cut>
      <type> rate </type>
      <description> CNO trigger rate passing the HIP Flight Software onboard filter</description>
    </object>

       <object>
      <name> FswHIP_AND_Trigger_TKR </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[FswFilters[2]>0 && condsummary&2]]></cut>
      <type> rate </type>
      <description> TKR trigger rate passing the HIP Flight Software onboard filter</description>
    </object>

       <object>
      <name> FswHIP_AND_Trigger_ROI </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[FswFilters[2]>0 && condsummary&1]]></cut>
      <type> rate </type>
      <description> ROI trigger rate passing the HIP Flight Software onboard filter</description>
    </object>



	 <object>
      <name> FswMIP_AND_Trigger_CALLO </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[FswFilters[1]>0 && condsummary&4  ]]></cut>
      <type> rate </type>
      <description> CAL-LO trigger rate passing the MIP Flight Software onboard filter</description>
    </object>


     <object>
      <name> FswMIP_AND_Trigger_CALHI </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[FswFilters[1]>0 && condsummary&8  ]]></cut>
      <type> rate </type>
      <description> CAL-HI trigger rate passing the MIP Flight Software onboard filter</description>
    </object>

      <object>
      <name> FswMIP_AND_Trigger_CNO </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[FswFilters[1]>0 && condsummary&16  ]]></cut>
      <type> rate </type>
      <description> CNO trigger rate passing the MIP Flight Software onboard filter</description>
    </object>

       <object>
      <name> FswMIP_AND_Trigger_TKR </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[FswFilters[1]>0 && condsummary&2]]></cut>
      <type> rate </type>
      <description> TKR trigger rate passing the MIP Flight Software onboard filter</description>
    </object>

       <object>
      <name> FswMIP_AND_Trigger_ROI </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[FswFilters[1]>0 && condsummary&1]]></cut>
      <type> rate </type>
      <description> ROI trigger rate passing the MIP Flight Software onboard filter</description>
    </object>

     
        <object>
      <name> Trigger_TKR_And_ROI_And_FswFilters_GAMMA </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[(condsummary&1) && (condsummary&2) && (FswFilters[0]>0)]]></cut>
      <type> rate </type>
      <description> Rate of TKR trigger and ROI (mostly charge particles) AND Flight Sowftware GAMMA Filter. We expect to have very low rates of events fulfilling those somewhat contradictory requirements.</description>
    </object>

     <object>
      <name> Trigger_TKR_And_NotROI_And_FswFilters_GAMMA </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[!(condsummary&1) && (condsummary&2) && (FswFilters[0]>0)]]></cut>
      <type> rate </type>
      <description> Rate of TKR trigger and not ROI (mostly non charge particles) AND Flight Sowftware GAMMA Filter. We expect to have essentially the same rate as without the GAMMA Filter. </description>
    </object>


         <object>
      <name> Trigger_TKR_And_ROI_And_FswFilters_MIP_OR_HIP </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[(condsummary&1) && (condsummary&2) && (FswFilters[1]>0 || FswFilters[2]>0)]]></cut>
      <type> rate </type>
      <description> Rate of TKR trigger and ROI (mostly charge particles) AND Flight Sowftware MIP or HIP Filter. </description>
    </object>

     <object>
      <name> Trigger_TKR_And_NotROI_And_FswFilters_MIP_OR_HIP </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[!(condsummary&1) && (condsummary&2) && (FswFilters[1]>0 || FswFilters[2]>0)]]></cut>
      <type> rate </type>
      <description> Rate of TKR trigger and not ROI (mostly non charge particles) AND Flight Sowftware MIP or HIP Filter. </description>
    </object>
	

         <object>
      <name> Trigger_TKR_And_ROI_And_FswFilters_DGN </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[(condsummary&1) && (condsummary&2) && (FswFilters[3]>0)]]></cut>
      <type> rate </type>
      <description> Rate of TKR trigger and ROI (mostly charge particles) AND Flight Sowftware DGN Filter. </description>
    </object>

     <object>
      <name> Trigger_TKR_And_NotROI_And_FswFilters_DGN </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[!(condsummary&1) && (condsummary&2) && (FswFilters[3]>0)]]></cut>
      <type> rate </type>
      <description> Rate of TKR trigger and not ROI (mostly non charge particles) AND Flight Sowftware DGN Filter. </description>
    </object>

         <object>
      <name> UnPrescaled_Trigger_TKR_And_ROI_And_FswFilters_DGN </name>
      <formula><![CDATA[ DGNGemPrescale ]]></formula>
      <cut><![CDATA[(condsummary&1) && (condsummary&2) && (FswFilters[3]>0)]]></cut>
      <type> rate </type>
      <description> Rate of TKR trigger and ROI (mostly charge particles) surviving the  Flight Sowftware DGN Filter, unprescaled with the DGN (engine dependent) prescale factor. </description>
    </object>

     <object>
      <name> UnPrescaled_Trigger_TKR_And_NotROI_And_FswFilters_DGN </name>
      <formula><![CDATA[ DGNGemPrescale ]]></formula>
      <cut><![CDATA[!(condsummary&1) && (condsummary&2) && (FswFilters[3]>0)]]></cut>
      <type> rate </type>
      <description> Rate of TKR trigger and not ROI (mostly non charge particles) surviving Flight Sowftware DGN Filter,unprescaled with the DGN (engine dependent) prescale factor. </description>
    </object>


     <!-- Fractions of events with/without Fsw and Gleam filters -->

     <object>
      <name> AllEvts_FswGAMMA </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[ FswFilters[0]>0]]></cut>
      <type> counter </type>
      <description> Counter for evts passing the Flight Software GAMMA filter (in the specified time bin). It will be used to normalize quantities. </description>
    </object>

      <object>
      <name> AllEvts_GleamGAMMA </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[ OBFStatus[0]>0]]></cut>
      <type> counter </type>
      <description> Counter for evts passing the Gleam GAMMA filter (in the specified time bin). It will be used to normalize quantities. </description>
    </object>
     
     <object>
      <name> Evts_FswGAMMA_And_GleamGAMMA </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[FswFilters[0]>0 &&  OBFStatus[0]>0]]></cut>
      <type> counter </type>
      <description> Counter of evts passing both the Flight Software GAMMA filter and the Gleam GAMMA filter. This quantity will be fully meaningful when normalized to the total number of events (i.e. converted into fraction). That meaningful quantity is called Normalized_Evts_FswGAMMA_And_GleamGAMMA. </description>
    </object>

     <object>
      <name> Normalized_Evts_FswGAMMA_And_GleamGAMMA </name>
      <formula><![CDATA[ foronetime: (Counter_AllEvts_FswGAMMA>0) ?  double(Counter_Evts_FswGAMMA_And_GleamGAMMA)/double(Counter_AllEvts_FswGAMMA) : 0.0 ]]></formula>
      <cut><![CDATA[]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Fraction of events passing both the Flight Software GAMMA filter and the Gleam GAMMA filter. The normalization factor is the number of events passing the Flight Software GAMMA filter.</description>
    </object>

     <object>
      <name> Normalized_Evts_FswGAMMA_And_GleamGAMMA_err </name>
      <formula><![CDATA[ foronetime: Counter_AllEvts_FswGAMMA> 0 ? sqrt((1./double(Counter_AllEvts_FswGAMMA))*(double(Counter_Evts_FswGAMMA_And_GleamGAMMA)/double(Counter_AllEvts_FswGAMMA))*(1-(double(Counter_Evts_FswGAMMA_And_GleamGAMMA)/double(Counter_AllEvts_FswGAMMA)))) : 0.0 ]]></formula>
      <cut><![CDATA[]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Error in Fraction of events passing both the Flight Software GAMMA filter and the Gleam GAMMA filter. </description>
    </object>


     <object>
      <name> Evts_FswGAMMA_And_NOTGleamGAMMA </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[FswFilters[0]>0 &&  OBFStatus[0]==0]]></cut>
      <type> counter </type>
      <description> Counter of evts passing the Flight Software GAMMA filter and NOT the Gleam GAMMA filter. This quantity will be fully meaningful when normalized to the total number of events (i.e. converted into fraction). That meaningful quantity is called Normalized_Evts_FswGAMMA_And_NOTGleamGAMMA. </description>
    </object>
     

     <object>
      <name> Normalized_Evts_FswGAMMA_And_NOTGleamGAMMA </name>
      <formula><![CDATA[ foronetime: (Counter_AllEvts_FswGAMMA>0) ?  double(Counter_Evts_FswGAMMA_And_NOTGleamGAMMA)/double(Counter_AllEvts_FswGAMMA) : 0.0 ]]></formula>
      <cut><![CDATA[]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Fraction of events passing the Flight Software GAMMA filter and NOT the Gleam GAMMA filter. The normalization factor is the number of events passing the Flight Software GAMMA filter.</description>
    </object>

     
     <object>
      <name> Normalized_Evts_FswGAMMA_And_NOTGleamGAMMA_err </name>
      <formula><![CDATA[ foronetime: Counter_AllEvts_FswGAMMA > 0 ? sqrt((1./double(Counter_AllEvts_FswGAMMA))*(double(Counter_Evts_FswGAMMA_And_NOTGleamGAMMA)/double(Counter_AllEvts_FswGAMMA))*(1-(double(Counter_Evts_FswGAMMA_And_NOTGleamGAMMA)/double(Counter_AllEvts_FswGAMMA)))) : 0.0 ]]></formula>
      <cut><![CDATA[]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Error in Fraction of events passing both the Flight Software GAMMA filter and NOT the Gleam GAMMA filter. </description>
    </object>


     <object>
      <name> Evts_NOTFswGAMMA_And_GleamGAMMA </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[FswFilters[0]==0 &&  OBFStatus[0]>0]]></cut>
      <type> counter </type>
      <description> Counter of evts NOT passing the Flight Software GAMMA filter and passing the Gleam GAMMA filter. This quantity will be fully meaningful when normalized to the total number of events (i.e. converted into fraction). That meaningful quantity is called Normalized_Evts_NOTFswGAMMA_And_GleamGAMMA. </description>
    </object>

      <object>
      <name> Normalized_Evts_NOTFswGAMMA_And_GleamGAMMA </name>
      <formula><![CDATA[ foronetime: (Counter_AllEvts_GleamGAMMA >0) ?  double(Counter_Evts_NOTFswGAMMA_And_GleamGAMMA)/double(Counter_AllEvts_GleamGAMMA) : 0.0 ]]></formula>
      <cut><![CDATA[]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Fraction of events NOT passing the Flight Software GAMMA filter and passing the Gleam GAMMA filter. The normalization factor is the number of events passing the Gleam GAMMA filter.</description>
    </object>

     <object>
      <name> Normalized_Evts_NOTFswGAMMA_And_GleamGAMMA_err </name>
      <formula><![CDATA[ foronetime: Counter_AllEvts_GleamGAMMA> 0 ? sqrt((1./double(Counter_AllEvts_GleamGAMMA))*(double(Counter_Evts_NOTFswGAMMA_And_GleamGAMMA)/double(Counter_AllEvts_GleamGAMMA))*(1-(double(Counter_Evts_NOTFswGAMMA_And_GleamGAMMA)/double(Counter_AllEvts_GleamGAMMA)))) : 0.0 ]]></formula>
      <cut><![CDATA[]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Error in Fraction of events NOT passing the Flight Software GAMMA filter and passing the Gleam GAMMA filter. </description>
    </object>


     <object>
      <name> AllEvts_FswMIP </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[ FswFilters[1]>0]]></cut>
      <type> counter </type>
      <description> Counter for evts passing the Flight Software MIP filter (in the specified time bin). It will be used to normalize quantities. </description>
    </object>

      <object>
      <name> AllEvts_GleamMIP </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[ OBFStatus[1]>0]]></cut>
      <type> counter </type>
      <description> Counter for evts passing the Gleam MIP filter (in the specified time bin). It will be used to normalize quantities. </description>
    </object>


     <object>
      <name> Evts_FswMIP_And_GleamMIP </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[FswFilters[1]>0 &&  OBFStatus[1]>0]]></cut>
      <type> counter </type>
      <description> Counter of evts passing both the Flight Software MIP filter and the Gleam MIP filter. This quantity will be fully meaningful when normalized to the total number of events (i.e. converted into fraction). That meaningful quantity is called Normalized_Evts_FswMIP_And_GleamMIP. </description>
    </object>

     <object>
      <name> Normalized_Evts_FswMIP_And_GleamMIP </name>
      <formula><![CDATA[ foronetime: (Counter_AllEvts_FswMIP>0) ?  double(Counter_Evts_FswMIP_And_GleamMIP)/double(Counter_AllEvts_FswMIP) : 0.0 ]]></formula>
      <cut><![CDATA[]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Fraction of events passing both the Flight Software MIP filter and the Gleam MIP filter. The normalization factor is the number of events passing the Flight Software MIP filter.</description>
    </object>

     <object>
      <name> Normalized_Evts_FswMIP_And_GleamMIP_err </name>
      <formula><![CDATA[ foronetime: Counter_AllEvts_FswMIP > 0 ? sqrt((1./double(Counter_AllEvts_FswMIP))*(double(Counter_Evts_FswMIP_And_GleamMIP)/double(Counter_AllEvts_FswMIP))*(1-(double(Counter_Evts_FswMIP_And_GleamMIP)/double(Counter_AllEvts_FswMIP)))) : 0.0 ]]></formula>
      <cut><![CDATA[]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Error in Fraction of events passing both the Flight Software MIP filter and the Gleam MIP filter. </description>
    </object>


     <object>
      <name> Evts_FswMIP_And_NOTGleamMIP </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[FswFilters[1]>0 &&  OBFStatus[1]==0]]></cut>
      <type> counter </type>
      <description> Counter of evts passing the Flight Software MIP filter and NOT the Gleam MIP filter. This quantity will be fully meaningful when normalized to the total number of events (i.e. converted into fraction). That meaningful quantity is called Normalized_Evts_FswMIP_And_NOTGleamMIP. </description>
    </object>
     

     <object>
      <name> Normalized_Evts_FswMIP_And_NOTGleamMIP </name>
      <formula><![CDATA[ foronetime: (Counter_AllEvts_FswMIP>0) ?  double(Counter_Evts_FswMIP_And_NOTGleamMIP)/double(Counter_AllEvts_FswMIP) : 0.0 ]]></formula>
      <cut><![CDATA[]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Fraction of events passing the Flight Software MIP filter and NOT the Gleam MIP filter. The normalization factor is the number of events passing the Flight Software MIP filter.</description>
    </object>

     
     <object>
      <name> Normalized_Evts_FswMIP_And_NOTGleamMIP_err </name>
      <formula><![CDATA[ foronetime: Counter_AllEvts_FswMIP> 0 ? sqrt((1./double(Counter_AllEvts_FswMIP))*(double(Counter_Evts_FswMIP_And_NOTGleamMIP)/double(Counter_AllEvts_FswMIP))*(1-(double(Counter_Evts_FswMIP_And_NOTGleamMIP)/double(Counter_AllEvts_FswMIP)))) : 0.0 ]]></formula>
      <cut><![CDATA[]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Error in Fraction of events passing both the Flight Software MIP filter and NOT the Gleam MIP filter. </description>
    </object>


     <object>
      <name> Evts_NOTFswMIP_And_GleamMIP </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[FswFilters[1]==0 &&  OBFStatus[1]>0]]></cut>
      <type> counter </type>
      <description> Counter of evts NOT passing the Flight Software MIP filter and passing the Gleam MIP filter. This quantity will be fully meaningful when normalized to the total number of events (i.e. converted into fraction). That meaningful quantity is called Normalized_Evts_NOTFswMIP_And_GleamMIP. </description>
    </object>

      <object>
      <name> Normalized_Evts_NOTFswMIP_And_GleamMIP </name>
      <formula><![CDATA[ foronetime: (Counter_AllEvts_GleamMIP>0) ?  double(Counter_Evts_NOTFswMIP_And_GleamMIP)/double(Counter_AllEvts_GleamMIP) : 0.0 ]]></formula>
      <cut><![CDATA[]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Fraction of events NOT passing the Flight Software MIP filter and passing the Gleam MIP filter. The normalization factor is the number of events passing the Gleam MIP filter.</description>
    </object>

     <object>
      <name> Normalized_Evts_NOTFswMIP_And_GleamMIP_err </name>
      <formula><![CDATA[ foronetime: Counter_AllEvts_GleamMIP> 0 ? sqrt((1./double(Counter_AllEvts_GleamMIP))*(double(Counter_Evts_NOTFswMIP_And_GleamMIP)/double(Counter_AllEvts_GleamMIP))*(1-(double(Counter_Evts_NOTFswMIP_And_GleamMIP)/double(Counter_AllEvts_GleamMIP)))) : 0.0 ]]></formula>
      <cut><![CDATA[]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Error in Fraction of events NOT passing the Flight Software MIP filter and passing the Gleam MIP filter. </description>
    </object>



    
      <object>
      <name> AllEvts_FswHIP </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[ FswFilters[2]>0]]></cut>
      <type> counter </type>
      <description> Counter for evts passing the Flight Software HIP filter (in the specified time bin). It will be used to normalize quantities. </description>
    </object>

      <object>
      <name> AllEvts_GleamHIP </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[ OBFStatus[2]>0]]></cut>
      <type> counter </type>
      <description> Counter for evts passing the Gleam HIP filter (in the specified time bin). It will be used to normalize quantities. </description>
    </object>


  <object>
      <name> Evts_FswHIP_And_GleamHIP </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[FswFilters[2]>0 &&  OBFStatus[2]>0]]></cut>
      <type> counter </type>
      <description> Counter of evts passing both the Flight Software HIP filter and the Gleam HIP filter. This quantity will be fully meaningful when normalized to the total number of events (i.e. converted into fraction). That meaningful quantity is called Normalized_Evts_FswHIP_And_GleamHIP. </description>
    </object>

     <object>
      <name> Normalized_Evts_FswHIP_And_GleamHIP </name>
      <formula><![CDATA[ foronetime: (Counter_AllEvts_FswHIP>0) ?  double(Counter_Evts_FswHIP_And_GleamHIP)/double(Counter_AllEvts_FswHIP) : 0.0 ]]></formula>
      <cut><![CDATA[]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Fraction of events passing both the Flight Software HIP filter and the Gleam HIP filter. The normalization factor is the number of events passing the Flight Software HIP filter.</description>
    </object>

     <object>
      <name> Normalized_Evts_FswHIP_And_GleamHIP_err </name>
      <formula><![CDATA[ foronetime: Counter_AllEvts_FswHIP> 0 ? sqrt((1./double(Counter_AllEvts_FswHIP))*(double(Counter_Evts_FswHIP_And_GleamHIP)/double(Counter_AllEvts_FswHIP))*(1-(double(Counter_Evts_FswHIP_And_GleamHIP)/double(Counter_AllEvts_FswHIP)))) : 0.0 ]]></formula>
      <cut><![CDATA[]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Error in Fraction of events passing both the Flight Software HIP filter and the Gleam HIP filter. </description>
    </object>


     <object>
      <name> Evts_FswHIP_And_NOTGleamHIP </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[FswFilters[2]>0 &&  OBFStatus[2]==0]]></cut>
      <type> counter </type>
      <description> Counter of evts passing the Flight Software HIP filter and NOT the Gleam HIP filter. This quantity will be fully meaningful when normalized to the total number of events (i.e. converted into fraction). That meaningful quantity is called Normalized_Evts_FswHIP_And_NOTGleamHIP. </description>
    </object>
     

     <object>
      <name> Normalized_Evts_FswHIP_And_NOTGleamHIP </name>
      <formula><![CDATA[ foronetime: (Counter_AllEvts_FswHIP>0) ?  double(Counter_Evts_FswHIP_And_NOTGleamHIP)/double(Counter_AllEvts_FswHIP) : 0.0 ]]></formula>
      <cut><![CDATA[]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Fraction of events passing the Flight Software HIP filter and NOT the Gleam HIP filter. The normalization factor is the number of events passing the Flight Software HIP filter.</description>
    </object>

     
     <object>
      <name> Normalized_Evts_FswHIP_And_NOTGleamHIP_err </name>
      <formula><![CDATA[ foronetime: Counter_AllEvts_FswHIP> 0 ? sqrt((1./double(Counter_AllEvts_FswHIP))*(double(Counter_Evts_FswHIP_And_NOTGleamHIP)/double(Counter_AllEvts_FswHIP))*(1-(double(Counter_Evts_FswHIP_And_NOTGleamHIP)/double(Counter_AllEvts_FswHIP))))  : 0.0 ]]></formula>
      <cut><![CDATA[]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Error in Fraction of events passing both the Flight Software HIP filter and NOT the Gleam HIP filter. </description>
    </object>


     <object>
      <name> Evts_NOTFswHIP_And_GleamHIP </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[FswFilters[2]==0 &&  OBFStatus[2]>0]]></cut>
      <type> counter </type>
      <description> Counter of evts NOT passing the Flight Software HIP filter and passing the Gleam HIP filter. This quantity will be fully meaningful when normalized to the total number of events (i.e. converted into fraction). That meaningful quantity is called Normalized_Evts_NOTFswHIP_And_GleamHIP. </description>
    </object>

      <object>
      <name> Normalized_Evts_NOTFswHIP_And_GleamHIP </name>
      <formula><![CDATA[ foronetime: (Counter_AllEvts_GleamHIP>0) ?  double(Counter_Evts_NOTFswHIP_And_GleamHIP)/double(Counter_AllEvts_GleamHIP) : 0.0 ]]></formula>
      <cut><![CDATA[]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Fraction of events NOT passing the Flight Software HIP filter and passing the Gleam HIP filter. The normalization factor is the number of events passing the Gleam HIP filter.</description>
    </object>

     <object>
      <name> Normalized_Evts_NOTFswHIP_And_GleamHIP_err </name>
      <formula><![CDATA[ foronetime: Counter_AllEvts_GleamHIP > 0 ? sqrt((1./double(Counter_AllEvts_GleamHIP))*(double(Counter_Evts_NOTFswHIP_And_GleamHIP)/double(Counter_AllEvts_GleamHIP))*(1-(double(Counter_Evts_NOTFswHIP_And_GleamHIP)/double(Counter_AllEvts_GleamHIP)))): 0.0 ]]></formula>
      <cut><![CDATA[]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Error in Fraction of events NOT passing the Flight Software HIP filter and passing the Gleam HIP filter. </description>
    </object>

 


     <object>
      <name> EvtsProcessed_EPU0 </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[ DatagramInfo[0]==0]]></cut>
      <type> rate </type>
      <description> Rate of evts processed by EPU0. </description>
    </object>

     <object>
      <name> EvtsProcessed_EPU1 </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[ DatagramInfo[0]==1]]></cut>
      <type> rate </type>
      <description> Rate of evts processed by EPU1. </description>
    </object>


     <object>
      <name> Datagram_EPU0 </name>
      <formula><![CDATA[ DatagramInfo[1] ]]></formula>
      <cut><![CDATA[ DatagramInfo[0]==0]]></cut>
      <type> counterdiffrate[100000,1,MC] </type>
      <description> Rate of datagrams from EPU0 (A datagram is about 64 kbytes of compressed data). </description>
    </object>

     <object>
      <name> Datagram_EPU1 </name>
      <formula><![CDATA[ DatagramInfo[1] ]]></formula>
      <cut><![CDATA[ DatagramInfo[0]==1]]></cut>
      <type> counterdiffrate[100000,1,MC] </type>
      <description> Rate of datagrams from EPU1 (A datagram is about 64kbytes of compressed data). </description>
    </object>

     <object>
      <name> Datagram_EPU0_And_EPU1 </name>
      <formula><![CDATA[ CounterDiffRate_Datagram_EPU0 + CounterDiffRate_Datagram_EPU1  ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <source> output </source>
      <type> outputfloat </type>
      <description> Rate of datagrams from EPU0+EPU1 (A datagram is about 64kbytes of compressed data). This rate, multiplied by 64kbytes, is a rough etimate of the bandwidth needed to transfer the data to the ground. </description>
    </object>

      <object>
      <name> Datagram_EPU0_And_EPU1_err </name>
      <formula><![CDATA[ TMath::Sqrt(pow(CounterDiffRate_Datagram_EPU0_err,2) + pow(CounterDiffRate_Datagram_EPU1_err,2))  ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <source> output </source>
      <type> outputfloat </type>
      <description> Error in quantity Datagram_EPU0_And_EPU1 </description>
    </object>

     
     <!-- fraction of events with agreement in first 5 bits in Gem/L1T words (Normalization is GemCondSummaryWord-->

  
     <object>
      <name> CondSummaryBit_1 </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[CondSummary5bits[0]>0]]></cut>
      <type> counter </type>
      <description> Counter of evts with the condsummary word bit 1 (ROI) set. This quantity is not meaningful by itself; it will be used to normalize other quantities. </description>
    </object>

     <object>
      <name> CondSummaryBit_1_And_L1TTriggerWordBit_1 </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[CondSummary5bits[0]>0 && L1TTriggerWord5bits[0]>0]]></cut>
      <type> counter </type>
      <description> Counter of evts with the condsummary word bit 1 AND the l1t trigger word bit 1 (ROI) set. This quantity is not meaningful by itself; it will be meaningul when being normalized with CondSummaryBit_1.  </description>
    </object>

      <object>
      <name> Normalized_CondSummaryBit_1_And_L1TTriggerWordBit_1 </name>
      <formula><![CDATA[ foronetime: (Counter_CondSummaryBit_1>0) ?  double(Counter_CondSummaryBit_1_And_L1TTriggerWordBit_1)/double(Counter_CondSummaryBit_1) : -1.0 ]]></formula>
      <cut><![CDATA[]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Fraction of events with both condsummary word bit 1 AND the l1t trigger word bit 1 (ROI) set. The normalization factor is the number of events with condsummary word bit 1 set. </description>
    </object>

     <object>
      <name> Normalized_CondSummaryBit_1_And_L1TTriggerWordBit_1_err </name>
      <formula><![CDATA[ foronetime: Counter_CondSummaryBit_1>0  ?  sqrt((1./double(Counter_CondSummaryBit_1))*double(Counter_CondSummaryBit_1_And_L1TTriggerWordBit_1)/double(Counter_CondSummaryBit_1)*(1.-(double(Counter_CondSummaryBit_1_And_L1TTriggerWordBit_1)/double(Counter_CondSummaryBit_1)))) : 0.0 ]]></formula>
      <cut><![CDATA[]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Error in Normalized_CondSummaryBit_1_And_L1TTriggerWordBit_1 </description>
    </object>


     <object>
      <name> CondSummaryBit_2 </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[CondSummary5bits[1]>0]]></cut>
      <type> counter </type>
      <description> Counter of evts with the condsummary word bit 2 (TKR) set. This quantity is not meaningful by itself; it will be used to normalize other quantities. </description>
    </object>

     <object>
      <name> CondSummaryBit_2_And_L1TTriggerWordBit_2 </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[CondSummary5bits[1]>0 && L1TTriggerWord5bits[1]>0]]></cut>
      <type> counter </type>
      <description> Counter of evts with the condsummary word bit 2 AND the l1t trigger word bit 2 (TKR) set. This quantity is not meaningful by itself; it will be meaningul when being normalized with CondSummaryBit_2.  </description>
    </object>

      <object>
      <name> Normalized_CondSummaryBit_2_And_L1TTriggerWordBit_2 </name>
      <formula><![CDATA[ foronetime: (Counter_CondSummaryBit_2>0) ?  double(Counter_CondSummaryBit_2_And_L1TTriggerWordBit_2)/double(Counter_CondSummaryBit_2) : -1.0 ]]></formula>
      <cut><![CDATA[]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Fraction of events with both condsummary word bit 2 AND the l1t trigger word bit 2 (TKR) set. The normalization factor is the number of events with condsummary word bit 2 set. </description>
    </object>

     <object>
      <name> Normalized_CondSummaryBit_2_And_L1TTriggerWordBit_2_err </name>
      <formula><![CDATA[ foronetime: Counter_CondSummaryBit_2>0  ?  sqrt((1./double(Counter_CondSummaryBit_2))*double(Counter_CondSummaryBit_2_And_L1TTriggerWordBit_2)/double(Counter_CondSummaryBit_2)*(1.-(double(Counter_CondSummaryBit_2_And_L1TTriggerWordBit_2)/double(Counter_CondSummaryBit_2))))   : 0.0 ]]></formula>
      <cut><![CDATA[]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Error in Normalized_CondSummaryBit_2_And_L1TTriggerWordBit_2 </description>
    </object>


     <object>
      <name> CondSummaryBit_3 </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[CondSummary5bits[2]>0]]></cut>
      <type> counter </type>
      <description> Counter of evts with the condsummary word bit 2 (Cal-Lo) set. This quantity is not meaningful by itself; it will be used to normalize other quantities. </description>
    </object>

     <object>
      <name> CondSummaryBit_3_And_L1TTriggerWordBit_3 </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[CondSummary5bits[2]>0 && L1TTriggerWord5bits[2]>0]]></cut>
      <type> counter </type>
      <description> Counter of evts with the condsummary word bit 3 AND the l1t trigger word bit 3 (Cal-Lo) set. This quantity is not meaningful by itself; it will be meaningul when being normalized with CondSummaryBit_3.  </description>
    </object>

      <object>
      <name> Normalized_CondSummaryBit_3_And_L1TTriggerWordBit_3 </name>
      <formula><![CDATA[ foronetime: (Counter_CondSummaryBit_3>0) ?  double(Counter_CondSummaryBit_3_And_L1TTriggerWordBit_3)/double(Counter_CondSummaryBit_3) : -1.0 ]]></formula>
      <cut><![CDATA[]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Fraction of events with both condsummary word bit 3 AND the l1t trigger word bit 3 (Cal-Lo) set. The normalization factor is the number of events with condsummary word bit 3 set. </description>
    </object>

     <object>
      <name> Normalized_CondSummaryBit_3_And_L1TTriggerWordBit_3_err </name>
      <formula><![CDATA[ foronetime: Counter_CondSummaryBit_3>0  ?  sqrt((1./double(Counter_CondSummaryBit_3))*double(Counter_CondSummaryBit_3_And_L1TTriggerWordBit_3)/double(Counter_CondSummaryBit_3)*(1.-(double(Counter_CondSummaryBit_3_And_L1TTriggerWordBit_3)/double(Counter_CondSummaryBit_3))))  : 0.0 ]]></formula>
      <cut><![CDATA[]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Error in Normalized_CondSummaryBit_3_And_L1TTriggerWordBit_3 </description>
    </object>


     <object>
      <name> CondSummaryBit_4 </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[CondSummary5bits[3]>0]]></cut>
      <type> counter </type>
      <description> Counter of evts with the condsummary word bit 4 (Cal-Hi) set. This quantity is not meaningful by itself; it will be used to normalize other quantities. </description>
    </object>

     <object>
      <name> CondSummaryBit_4_And_L1TTriggerWordBit_4 </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[CondSummary5bits[3]>0 && L1TTriggerWord5bits[3]>0]]></cut>
      <type> counter </type>
      <description> Counter of evts with the condsummary word bit 4 AND the l1t trigger word bit 4 (Cal-Hi) set. This quantity is not meaningful by itself; it will be meaningul when being normalized with CondSummaryBit_4.  </description>
    </object>

      <object>
      <name> Normalized_CondSummaryBit_4_And_L1TTriggerWordBit_4 </name>
      <formula><![CDATA[ foronetime: (Counter_CondSummaryBit_4>0) ?  double(Counter_CondSummaryBit_4_And_L1TTriggerWordBit_4)/double(Counter_CondSummaryBit_4) : -1.0 ]]></formula>
      <cut><![CDATA[]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Fraction of events with both condsummary word bit 4 AND the l1t trigger word bit 4 (Cal-Hi) set. The normalization factor is the number of events with condsummary word bit 4 set. </description>
    </object>

     <object>
      <name> Normalized_CondSummaryBit_4_And_L1TTriggerWordBit_4_err </name>
      <formula><![CDATA[ foronetime: Counter_CondSummaryBit_4>0  ?  sqrt((1./double(Counter_CondSummaryBit_4))*double(Counter_CondSummaryBit_4_And_L1TTriggerWordBit_4)/double(Counter_CondSummaryBit_4)*(1.-(double(Counter_CondSummaryBit_4_And_L1TTriggerWordBit_4)/double(Counter_CondSummaryBit_4))))  : 0.0 ]]></formula>
      <cut><![CDATA[]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Error in Normalized_CondSummaryBit_4_And_L1TTriggerWordBit_4 </description>
    </object>


     <object>
      <name> CondSummaryBit_5 </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[CondSummary5bits[4]>0]]></cut>
      <type> counter </type>
      <description> Counter of evts with the condsummary word bit 1 (ROI) set. This quantity is not meaningful by itself; it will be used to normalize other quantities. </description>
    </object>

     <object>
      <name> CondSummaryBit_5_And_L1TTriggerWordBit_5 </name>
      <formula><![CDATA[ 1 ]]></formula>
      <cut><![CDATA[CondSummary5bits[4]>0 && L1TTriggerWord5bits[4]>0]]></cut>
      <type> counter </type>
      <description> Counter of evts with the condsummary word bit 5 AND the l1t trigger word bit 5 (CNO) set. This quantity is not meaningful by itself; it will be meaningul when being normalized with CondSummaryBit_5.  </description>
    </object>

      <object>
      <name> Normalized_CondSummaryBit_5_And_L1TTriggerWordBit_5 </name>
      <formula><![CDATA[ foronetime: (Counter_CondSummaryBit_5>0) ?  double(Counter_CondSummaryBit_5_And_L1TTriggerWordBit_5)/double(Counter_CondSummaryBit_5) : -1.0 ]]></formula>
      <cut><![CDATA[]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Fraction of events with both condsummary word bit 5 AND the l1t trigger word bit 5 (CNO) set. The normalization factor is the number of events with condsummary word bit 5 set. </description>
    </object>

     <object>
      <name> Normalized_CondSummaryBit_5_And_L1TTriggerWordBit_5_err </name> <!-- Binomial error, normalized to number of events -->
      <formula><![CDATA[ foronetime: Counter_CondSummaryBit_5>0  ?  sqrt((1./double(Counter_CondSummaryBit_5))*double(Counter_CondSummaryBit_5_And_L1TTriggerWordBit_5)/double(Counter_CondSummaryBit_5)*(1.-(double(Counter_CondSummaryBit_5_And_L1TTriggerWordBit_5)/double(Counter_CondSummaryBit_5))))  : 0.0 ]]></formula>
      <cut><![CDATA[]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Error in Normalized_CondSummaryBit_5_And_L1TTriggerWordBit_5 </description>
    </object>



      <!-- ********************  Detector information   *********************** -->


      <!--  ______________  ACD  _______________ -->

     
       <object>
	<name> AcdDigis </name>
	<formula><![CDATA[ RFun::loopoveracdtilesbool(AcdHit_AcdTile)]]></formula>
	<cut><![CDATA[condsummary&30]]></cut>
	<type> rate </type>
	<description> Rate of ACD Digis. </description>
      </object>

     
        <object>
	<name> AcdGemVeto_AcdTile[128] </name>
	<formula><![CDATA[ foreachacdtile: AcdGemVeto_AcdTile[acdtile] ]]></formula>
	<cut><![CDATA[condsummary&30]]></cut>
	<type> rate </type>
	<description> Vector [AcdTile] reporting the rate of ACD GEM vetos. </description>
      </object>

      <object>
	<name> AcdGemROI_Tower[16] </name>
	<formula><![CDATA[ foreachtower: AcdGemROI_Tower[tower] ]]></formula>
	<cut><![CDATA[condsummary&30]]></cut>
	<type> rate </type>
	<description> Vector [tower] reporting the rate of ACD GEM ROI. </description>
      </object>

       <object>
	<name> AcdGemCNO_GARC[12] </name>
	<formula><![CDATA[ foreachgarc: AcdGemCNO_GARC[garc] ]]></formula>
	<cut><![CDATA[condsummary&30]]></cut>
	<type> rate </type>
	<description> Vector [GARC] reporting the rate of ACD CNO triggers.</description>
      </object>

       <object>
	<name> AcdHit_AcdTile[128] </name>
	<formula><![CDATA[ foreachacdtile: AcdHit_AcdTile[acdtile] ]]></formula>
	<cut><![CDATA[condsummary&30]]></cut>
	<type> rate </type>
	<description> Vector [AcdTile] reporting the rate of ACD hits. </description>
      </object>



     <object>
      <name> Normalized_AcdHit_AcdTile[128] </name>
      <formula><![CDATA[foreachacdtile:  Rate_Trigger_NOTPeriodic >0 ? (Rate_AcdHit_AcdTile[acdtile]/Rate_Trigger_NOTPeriodic) : 0.0 ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Vector [acdtile] reporting the normalized number hits in the ACD tile defined by coordinate acdtile. The used normalization factor is the number of NOT periodic triggers. This is an indicator of the OCCUPANCY IN THE ACD. </description>
    </object>



      <object>
      <name> Normalized_AcdHit_AcdTile_err[128]  </name>
      <formula><![CDATA[foreachacdtile: ( Rate_Trigger_NOTPeriodic >0 && Rate_AcdHit_AcdTile[acdtile] >0 ) ? (Rate_AcdHit_AcdTile[acdtile]/Rate_Trigger_NOTPeriodic * TMath::Sqrt(pow(Rate_Trigger_NOTPeriodic_err/Rate_Trigger_NOTPeriodic,2)+pow(Rate_AcdHit_AcdTile_err[acdtile]/Rate_AcdHit_AcdTile[acdtile],2))) : 0.0 ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Vector [acdtile] reporting the error in quantity  OutF_Normalized_AcdHit_AcdTile. </description>
    </object>





       <object>
	<name> AcdPmtA_OverThreshold_AcdTile[128] </name>
	<formula><![CDATA[ foreachacdtile: AcdPmtA_OverThreshold_AcdTile[acdtile]]]></formula>
	<cut><![CDATA[condsummary&30]]></cut>
	<type> rate </type>
	<description> Vector[AcdTile] reporting the rate of PMT A being above threshold. </description>
      </object>

      
       <object>
	<name> AcdPmtB_OverThreshold_AcdTile[128] </name>
	<formula><![CDATA[foreachacdtile: AcdPmtB_OverThreshold_AcdTile[acdtile] ]]></formula>
	<cut><![CDATA[condsummary&30]]></cut>
	<type> rate </type>
	<description>Vector[AcdTile] reporting the rate of PMT B being above threshold.</description>
      </object>

       <object>
	<name> SingleAcdPmt_OverThreshold_AcdTile[128] </name>
	<formula><![CDATA[foreachacdtile: (AcdPmtA_OverThreshold_AcdTile[acdtile] && !AcdPmtB_OverThreshold_AcdTile[acdtile]) || (AcdPmtB_OverThreshold_AcdTile[acdtile] && !AcdPmtA_OverThreshold_AcdTile[acdtile])]]></formula>
	<cut><![CDATA[condsummary&30]]></cut>
	<type> rate </type>
	<description>Vector[AcdTile] reporting the rate of ONE (and only one) of the two PMTs (A OR B) being above threshold.  </description>
      </object>
       

       <object>
	<name> AnyAcdPmt_OverThreshold_AcdTile[128] </name>
	<formula><![CDATA[foreachacdtile: AcdPmtA_OverThreshold_AcdTile[acdtile] || AcdPmtB_OverThreshold_AcdTile[acdtile]]]></formula>
	<cut><![CDATA[condsummary&30]]></cut>
	<type> rate </type>
	<description>Vector[AcdTile] reporting the rate of at least one PMT being above threshold. </description>
      </object>


       <object>
	 <name> AcdPmt_OverThreshold_Asymmetry_AcdTile[128] </name>
	<formula><![CDATA[foreachacdtile: Rate_AnyAcdPmt_OverThreshold_AcdTile[acdtile] > 0 ? (Rate_AcdPmtA_OverThreshold_AcdTile[acdtile]-Rate_AcdPmtB_OverThreshold_AcdTile[acdtile])/Rate_AnyAcdPmt_OverThreshold_AcdTile[acdtile] : 0.0]]></formula>
	<cut><![CDATA[ ]]></cut>
	<source>output</source>
	<type> outputfloat </type>
	<description>Vector[AcdTile] reporting the A-B PMT over threshold asymmetry. The asymmetry is defined as A-B/(A OR B). </description>
      </object>

       <object>
	 <name> AcdPmt_OverThreshold_Asymmetry_AcdTile_err[128] </name>
	<formula><![CDATA[foreachacdtile: Rate_AnyAcdPmt_OverThreshold_AcdTile[acdtile] > 0 && (Rate_AcdPmtA_OverThreshold_AcdTile[acdtile]-Rate_AcdPmtB_OverThreshold_AcdTile[acdtile])!=0 ? TMath::Abs((Rate_AcdPmtA_OverThreshold_AcdTile[acdtile]-Rate_AcdPmtB_OverThreshold_AcdTile[acdtile])/Rate_AnyAcdPmt_OverThreshold_AcdTile[acdtile])*TMath::Sqrt(pow(TMath::Sqrt(pow(Rate_AcdPmtA_OverThreshold_AcdTile_err[acdtile],2)+pow(Rate_AcdPmtB_OverThreshold_AcdTile_err[acdtile],2))/(Rate_AcdPmtA_OverThreshold_AcdTile[acdtile]-Rate_AcdPmtB_OverThreshold_AcdTile[acdtile]),2)+pow(Rate_AnyAcdPmt_OverThreshold_AcdTile_err[acdtile]/Rate_AnyAcdPmt_OverThreshold_AcdTile[acdtile],2)) : 0.0 ]]></formula>
	<cut><![CDATA[ ]]></cut>
	<source>output</source>
	<type> outputfloat </type>
	<description>Vector[AcdTile] reporting the error in quantity A-B PMT over threshold asymmetry (AcdPmt_OverThreshold_Asymmetry_AcdTile).  </description>
      </object>

        
        <object>
	<name> AcdVetoA_AcdTile[128]  </name>
	<formula><![CDATA[ foreachacdtile: AcdVetoA_AcdTile[acdtile] ]]></formula>
	<cut><![CDATA[condsummary&30]]></cut>
	<type> rate </type>
	<description> Vector[AcdTile] reporting the rate of vetos from PMT A.</description>
      </object>

	<object>
	<name> AcdVetoB_AcdTile[128]  </name>
	<formula><![CDATA[ foreachacdtile: AcdVetoB_AcdTile[acdtile] ]]></formula>
	<cut><![CDATA[condsummary&30]]></cut>
	<type> rate </type>
	<description> Vector[AcdTile] reporting the rate of vetos from PMT B. </description>
      </object>
    

	<object>
	<name> SingleAcdVeto_AcdTile[128]  </name>
	<formula><![CDATA[ foreachacdtile:  (AcdVetoA_AcdTile[acdtile] && !AcdVetoB_AcdTile[acdtile]) || (!AcdVetoA_AcdTile[acdtile] && AcdVetoB_AcdTile[acdtile])   ]]></formula>
	<cut><![CDATA[condsummary&30]]></cut>
	<type> rate </type>
	<description> Vector[AcdTile] reporting the rate of ONE (and only one) of the two PMTs producing a Veto.</description>
      </object>


	<object>
	<name> AnyAcdVeto_AcdTile[128]  </name>
	<formula><![CDATA[ foreachacdtile:  AcdVetoA_AcdTile[acdtile] || AcdVetoB_AcdTile[acdtile]   ]]></formula>
	<cut><![CDATA[condsummary&30]]></cut>
	<type> rate </type>
	<description> Vector[AcdTile] reporting the rate of ACD Vetos (produced by one or by the two PMTs).  </description>
      </object>
   
	<object>
	 <name> AcdPmt_Veto_Asymmetry_AcdTile[128] </name>
	<formula><![CDATA[foreachacdtile: Rate_AnyAcdVeto_AcdTile[acdtile] > 0 ? (Rate_AcdVetoA_AcdTile[acdtile]-Rate_AcdVetoB_AcdTile[acdtile])/Rate_AnyAcdVeto_AcdTile[acdtile] : 0.0]]></formula>
	<cut><![CDATA[ ]]></cut>
	<source>output</source>
	<type> outputfloat </type>
	<description>Vector[AcdTile] reporting the A-B PMT VETO asymmetry. The asymmetry is defined as A-B/(A OR B). </description>
      </object>

       <object>
	 <name> AcdPmt_Veto_Asymmetry_AcdTile_err[128] </name>
	<formula><![CDATA[foreachacdtile: Rate_AnyAcdVeto_AcdTile[acdtile] > 0 && (Rate_AcdVetoA_AcdTile[acdtile]-Rate_AcdVetoB_AcdTile[acdtile])!=0 ? TMath::Abs((Rate_AcdVetoA_AcdTile[acdtile]-Rate_AcdVetoB_AcdTile[acdtile])/Rate_AnyAcdVeto_AcdTile[acdtile])*TMath::Sqrt(pow(TMath::Sqrt(pow(Rate_AcdVetoA_AcdTile_err[acdtile],2)+pow(Rate_AcdVetoB_AcdTile_err[acdtile],2))/(Rate_AcdVetoA_AcdTile[acdtile]-Rate_AcdVetoB_AcdTile[acdtile]),2)+pow(Rate_AnyAcdVeto_AcdTile_err[acdtile]/Rate_AnyAcdVeto_AcdTile[acdtile],2)) : 0.0 ]]></formula>
	<cut><![CDATA[ ]]></cut>
	<source>output</source>
	<type> outputfloat </type>
	<description>Vector[AcdTile] reporting the error in quantity A-B PMT VETO asymmetry (AcdPmt_OverThreshold_Asymmetry_AcdTile).  </description>
      </object>



	<object>
	<name>  AcdPha_PmtA_AcdTile[128] </name>
	<formula><![CDATA[AcdPha_PmtIdPmtRangeAcdTile[0][0] ]]></formula>
	<cut><![CDATA[condsummary&30]]></cut>
	<type> mean </type>
	<description> Vector [AcdTile] reporting the mean pulse height from PMT A  during the specified time bin. Only the LOW PMT range is being considered. </description>
      </object>


      <object>
	<name>  AcdPha_PmtB_AcdTile[128] </name>
	<formula><![CDATA[AcdPha_PmtIdPmtRangeAcdTile[1][0] ]]></formula>
	<cut><![CDATA[condsummary&30]]></cut>
	<type> mean </type>
	<description> Vector [AcdTile] reporting the mean pulse height from PMT B during the specified time bin. Only the LOW PMT range is being considered.   </description>
      </object>

   
        


      <!--  ______________  Tracker _______________ -->

   

    <object>
      <name> TkrTotalHits </name>
      <formula><![CDATA[ RFun::loopovertowerANDtkrplanes(TkrHitsTowerPlane) ]]></formula>
      <cut><![CDATA[ condsummary&30]]></cut>
      <type> rate </type>
      <description> Rate of tracker hits (all towers and planes included). </description>
    </object>

    <object>
      <name> TkrTotalHitsPerEvt </name>
      <formula><![CDATA[ RFun::loopovertowerANDtkrplanes(TkrHitsTowerPlane) ]]></formula>
      <cut><![CDATA[ condsummary&30]]></cut>
      <type> mean </type>
      <description> Mean number of tracker hits (all towers and planes included) per event. </description>
    </object>


    

    <object>
      <name> TkrHits_Tower[16] </name>
      <formula><![CDATA[ foreachtower: RFun::loopovertkrplanes(TkrHitsTowerPlane[tower]) ]]></formula>
      <cut><![CDATA[condsummary&30 ]]></cut>
      <type> rate </type>
      <description> Rate of tracker hits in [tower]. </description>
    </object>


    <object>
      <name> TkrHitsPerEvt_Tower[16] </name>
      <formula><![CDATA[ foreachtower: RFun::loopovertkrplanes(TkrHitsTowerPlane[tower]) ]]></formula>
      <cut><![CDATA[condsummary&30 ]]></cut>
      <type> mean </type>
      <description> Mean number of tracker hits in [tower]. </description>
    </object>

    

    
    <object>
      <name> TkrHits_TowerPlane[16][36] </name>
      <formula><![CDATA[ foreachtower: foreachtkrplane: TkrHitsTowerPlane[tower][tkrplane] ]]></formula>
      <cut><![CDATA[ condsummary&30]]></cut>
      <type> rate </type>
      <description> Rate of tracker hits in [tower][tkrplane]. </description>
    </object>

    
     <object>
      <name> TkrHitsPerEvt_TowerPlane[16][36] </name>
      <formula><![CDATA[ foreachtower: foreachtkrplane: TkrHitsTowerPlane[tower][tkrplane] ]]></formula>
      <cut><![CDATA[ condsummary&30]]></cut>
      <type> mean </type>
      <description> Mean number of tracker hits in [tower][tkrplane]. </description>
    </object>

      <object>
      <name> NTkrHits_TowerPlane[16][36] </name>
      <formula><![CDATA[ foreachtower: foreachtkrplane: TkrHitsTowerPlane[tower][tkrplane] ]]></formula>
      <cut><![CDATA[ condsummary==32]]></cut>
      <type> rate </type>
      <description> Rate of tracker hits in [tower][tkrplane] during periodic triggers. This is an indicator of the noise in the tracker. </description>
    </object>
    

   

 
     <object>
      <name> Normalized_TkrHits_TowerPlane[16][36] </name>
      <formula><![CDATA[foreachtower: foreachtkrplane:   Rate_Trigger_NOTPeriodic >0 ? (Rate_TkrHits_TowerPlane[tower][tkrplane]/Rate_Trigger_NOTPeriodic) : 0.0 ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Vector  [tower][tkrplane] reporting the normalized number hits in the tracker plane defined by coordinates tower,tkrplane. The used normalization factor is the number of NOT periodic triggers. This is an indicator of the OCCUPANCY IN THE TRACKER. </description>
    </object>



      <object>
      <name> Normalized_TkrHits_TowerPlane_err[16][36]   </name>
      <formula><![CDATA[ foreachtower: foreachtkrplane:  (Rate_Trigger_NOTPeriodic >0 && Rate_TkrHits_TowerPlane[tower][tkrplane] >0 ) ? (Rate_TkrHits_TowerPlane[tower][tkrplane]/Rate_Trigger_NOTPeriodic * TMath::Sqrt(pow(Rate_Trigger_NOTPeriodic_err/Rate_Trigger_NOTPeriodic,2)+pow(Rate_TkrHits_TowerPlane_err[tower][tkrplane]/Rate_TkrHits_TowerPlane[tower][tkrplane],2))) : 0.0 ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Vector [tower][tkrplane] reporting the error in quantity  OutF_Normalized_TkrHits_TowerPlane. </description>
    </object>
    
         <object>
      <name> Normalized_NTkrHits_TowerPlane[16][36] </name>
      <formula><![CDATA[foreachtower: foreachtkrplane:   Rate_Trigger_Periodic >0 ? (Rate_NTkrHits_TowerPlane[tower][tkrplane]/Rate_Trigger_Periodic) : 0.0 ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Vector  [tower][tkrplane] reporting the normalized number hits in the tracker plane defined by coordinates tower,tkrplane during periodic triggers. The used normalization factor is the number of periodic triggers. This is an good indicator of noise in the tracker. </description>
    </object>


      <object>
      <name> Normalized_NTkrHits_TowerPlane_err[16][36]   </name>
      <formula><![CDATA[ foreachtower: foreachtkrplane:  (Rate_Trigger_Periodic >0 && Rate_NTkrHits_TowerPlane[tower][tkrplane] >0 ) ? (Rate_NTkrHits_TowerPlane[tower][tkrplane]/Rate_Trigger_Periodic * TMath::Sqrt(pow(Rate_Trigger_Periodic_err/Rate_Trigger_Periodic,2)+pow(Rate_NTkrHits_TowerPlane_err[tower][tkrplane]/Rate_NTkrHits_TowerPlane[tower][tkrplane],2))) : 0.0 ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Vector [tower][tkrplane] reporting the error in quantity  OutF_Normalized_NTkrHits_TowerPlane. </description>
    </object>



     <object>
      <name> TkrTriggerWithLessThan6Layers_Tower[16] </name>
      <formula><![CDATA[ foreachtower: TkrTriggerTower[tower]&&(RFun::getconsecutiveplaneshit(TkrHitsTowerPlane[tower])<6) ]]></formula>
      <cut><![CDATA[ condsummary&30]]></cut>
      <type> rate </type>
      <description> Vector [tower] reporting the rate of events in which there was a tracker trigger and the number of consecutive tracker planes hit is less than 6. </description>
    </object>

     <object>
      <name> NormalizedTkrTriggerWithLessThan6Layers_Tower[16] </name>
      <formula><![CDATA[foreachtower: Rate_TkrTrigger_Tower[tower] >0.0 ? (Rate_TkrTriggerWithLessThan6Layers_Tower[tower]/Rate_TkrTrigger_Tower[tower]) : 0.0 ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Vector [tower] reporting the normalized number of events in which there was a tracker trigger and the number of consecutive tracker planes hit is less than 6. The used normalization factor is the Tkr Triggers in the specific [tower]. This is a meanigful parameter reporting about the HIT INEFFICIENCY in that [tower]. </description>
    </object>


     <object>
      <name> NormalizedTkrTriggerWithLessThan6Layers_Tower_err[16] </name>
      <formula><![CDATA[foreachtower: (Rate_TkrTrigger_Tower[tower] >0.0 && Rate_TkrTrigger_Tower_err[tower] > 0.0) ? sqrt((1./double(pow(Rate_TkrTrigger_Tower[tower]/Rate_TkrTrigger_Tower_err[tower],2)))*(Rate_TkrTriggerWithLessThan6Layers_Tower[tower]/Rate_TkrTrigger_Tower[tower])*(1-(Rate_TkrTriggerWithLessThan6Layers_Tower[tower]/Rate_TkrTrigger_Tower[tower]))): 0.0 ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Vector [tower] reporting the error in quantity OutF_NormalizedTkrTriggerWithLessThan6Layers_Tower.  </description>
    </object>
     

    


     <object>
      <name> ConsecutivePlanesHit_Tower[16] </name>
      <formula><![CDATA[ foreachtower: TkrTriggerTower[tower]>0 ? (RFun::getconsecutiveplaneshit(TkrHitsTowerPlane[tower])) : -1.0 ]]></formula>
      <cut><![CDATA[ condsummary&30]]></cut>
      <type> truncatedmean[1,36] </type>
      <description> Mean number of consecutive tracker planes hit in [tower] per event triggereing that [tower] </description>
    </object>

     <object>
      <name> EmptyTowers_Tower[16] </name>
      <formula><![CDATA[runonce: RFun::getemptytowers(TkrTriggerTower)# foreachtower: runonceformula[tower] > 0.5 ]]></formula>
      <cut><![CDATA[condsummary&30 ]]></cut>
      <type> counter </type>
      <description> Number of times [tower] did not trigger and was not boundary to a tower that triggered </description>
    </object>

     <object>
      <name> HitsInEmptyTower_Tower[16] </name>
      <formula><![CDATA[runonce: RFun::getemptytowers(TkrTriggerTower)# foreachtower: RFun::gethitsinemptytower(runonceformula[tower],TkrHitsTowerPlane[tower]) ]]></formula>
      <cut><![CDATA[ condsummary&30]]></cut>
      <type> counter </type>
      <description> Number of hits when the tower was empty </description>
    </object>

     <object>
      <name> NormalizedHitsInEmptyTower_Tower[16] </name>
      <formula><![CDATA[foreachtower: Counter_EmptyTowers_Tower[tower] >0 ? (Counter_HitsInEmptyTower_Tower[tower]/double(Counter_EmptyTowers_Tower[tower])) : 0.0 ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Vector [tower] reporting the normalized number of hits when the tower was empty: HitsInEmptyTower_Tower/EmptyTowers_Tower. This good indicator of the NOISE OCCUPANCY in that [tower].</description>
    </object>

      <object>
      <name> NormalizedHitsInEmptyTower_Tower_err[16] </name>
      <formula><![CDATA[foreachtower: Counter_EmptyTowers_Tower[tower] >0 && Counter_HitsInEmptyTower_Tower[tower] >0 ? ((Counter_HitsInEmptyTower_Tower[tower]/double(Counter_EmptyTowers_Tower[tower]))*TMath::Sqrt(1./double(Counter_EmptyTowers_Tower[tower])+1./double(Counter_HitsInEmptyTower_Tower[tower]))) : 0.0 ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Vector  [tower] reporting the error in quantity OutF_NormalizedHitsInEmptyTower_Tower. </description>
    </object>



      <object>
      <name> TkrDigi_TowerPlane[16][36] </name>
      <formula><![CDATA[foreachtower: foreachtkrplane : IsTkrDigi_TowerPlane[tower][tkrplane] > 0.5 ]]></formula>
      <cut><![CDATA[ condsummary&30]]></cut>
      <type> rate </type>
      <description> Vector [tower][tkrplane] reporting the rate of TkrDigi objects.</description>
    </object>



     <object>
      <name> TkrDigi_Tower[16] </name>
      <formula><![CDATA[foreachtower: RFun::loopovertkrplanes(IsTkrDigi_TowerPlane[tower]) ]]></formula>
      <cut><![CDATA[ condsummary&30]]></cut>
      <type> rate </type>
      <description> Vector [tower] reporting the rate of TkrDigi objects.</description>
    </object>


   
     <object>
      <name> TkrDigi </name>
      <formula><![CDATA[ RFun::loopovertowerANDtkrplanes(IsTkrDigi_TowerPlane) ]]></formula>
      <cut><![CDATA[ condsummary&30]]></cut>
      <type> rate </type>
      <description> Rate of TkrDigis (all towers and planes included).</description>
    </object>

  

     <object>
      <name> ToT_con0_250_TowerPlane[16][36] </name>
      <formula><![CDATA[foreachtower: foreachtkrplane: ToT_con0_TowerPlane[tower][tkrplane]==250 ]]></formula>
      <cut><![CDATA[ condsummary&30]]></cut>
      <type> rate </type>
      <description> Vector [tower][tkrtracker] reporting the rate of ToT==250 (saturation) in controller 0. </description>
    </object>

     <object>
      <name> ToT_con1_250_TowerPlane[16][36] </name>
      <formula><![CDATA[foreachtower: foreachtkrplane: ToT_con1_TowerPlane[tower][tkrplane]==250 ]]></formula>
      <cut><![CDATA[ condsummary&30]]></cut>
      <type> rate </type>
      <description> Vector [tower][tkrtracker] reporting the rate of ToT==250 (saturation) in controller 1. </description>
    </object>

     <object>
      <name> ToT_250_TowerPlane[16][36] </name>
      <formula><![CDATA[foreachtower: foreachtkrplane: ToT_con0_TowerPlane[tower][tkrplane]==250 || ToT_con1_TowerPlane[tower][tkrplane]==250]]></formula>
      <cut><![CDATA[condsummary&30 ]]></cut>
      <type> rate </type>
      <description> Vector [tower][tkrtracker] reporting the rate of ToT==250 (saturation) in either controller 0 or controller 1.  </description>
    </object>
     

     
      <object>
      <name> Normalized_ToT_250_TowerPlane[16][36]  </name>
      <formula><![CDATA[foreachtower: foreachtkrplane: Rate_TkrDigi_TowerPlane[tower][tkrplane] >0 ? (Rate_ToT_250_TowerPlane[tower][tkrplane]/Rate_TkrDigi_TowerPlane[tower][tkrplane]) : 0.0 ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Vector [tower][tkrplane] reporting the normalized of number of events in with ToT==250 (saturation) in either controller 0 or controller 1. The used normalization factor is the number of Tkr Digis in that [tower][tkrplane]. This is a good indicator of events with SIGNAL OVERFLOW. </description>
    </object>


      <object>
      <name> Normalized_ToT_250_TowerPlane_err[16][36] </name>
      <formula><![CDATA[foreachtower: foreachtkrplane: ( Rate_TkrDigi_TowerPlane[tower][tkrplane] >0 && Rate_TkrDigi_TowerPlane_err[tower][tkrplane] >0 ) ? sqrt((1./double(pow(Rate_TkrDigi_TowerPlane[tower][tkrplane]/Rate_TkrDigi_TowerPlane_err[tower][tkrplane],2)))*(Rate_ToT_250_TowerPlane[tower][tkrplane]/Rate_TkrDigi_TowerPlane[tower][tkrplane])*(1-(Rate_ToT_250_TowerPlane[tower][tkrplane]/Rate_TkrDigi_TowerPlane[tower][tkrplane]))) : 0.0 ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Vector [tower][tkrplane] reporting the error in quantity  OutF_Normalized_ToT_250_TowerPlane. </description>
    </object>




    <object>
      <name> ToT_con0_0_TowerPlane[16][36] </name>
      <formula><![CDATA[foreachtower: foreachtkrplane: IsTkrDigi_TowerPlane[tower][tkrplane]>0.5 && ToT_con0_TowerPlane[tower][tkrplane]==0 ]]></formula>
      <cut><![CDATA[ condsummary&30]]></cut>
      <type> rate </type>
      <description> Vector [tower][tkrtracker] reporting the rate of ToT==0, in controller 0. Only events for which TkrDigi exists for that tower,tkrplane are considered. </description>
    </object>

     <object>
      <name> ToT_con1_0_TowerPlane[16][36] </name>
      <formula><![CDATA[foreachtower: foreachtkrplane: IsTkrDigi_TowerPlane[tower][tkrplane]>0.5 && ToT_con1_TowerPlane[tower][tkrplane]==0 ]]></formula>
      <cut><![CDATA[ condsummary&30]]></cut>
      <type> rate </type>
      <description> Vector [tower][tkrtracker] reporting the rate of ToT==0, in controller 1. Only events for which TkrDigi exists for that tower,tkrplane are considered. </description>
    </object>

     <object>
      <name> ToT_0_TowerPlane[16][36] </name>
      <formula><![CDATA[foreachtower: foreachtkrplane: IsTkrDigi_TowerPlane[tower][tkrplane]>0.5 && ToT_con0_TowerPlane[tower][tkrplane]==0 && ToT_con1_TowerPlane[tower][tkrplane]==0 ]]></formula>
      <cut><![CDATA[ condsummary&30]]></cut>
      <type> rate </type>
      <description> Vector [tower][tkrtracker] reporting the rate of ToT==0 for both controller 0 and controller 1. Only events for which TkrDigi exists for that tower,tkrplane are considered.  </description>
    </object>


      
      <object>
      <name> Normalized_ToT_0_TowerPlane[16][36]  </name>
      <formula><![CDATA[foreachtower: foreachtkrplane: Rate_TkrDigi_TowerPlane[tower][tkrplane] >0 ? (Rate_ToT_0_TowerPlane[tower][tkrplane]/Rate_TkrDigi_TowerPlane[tower][tkrplane]) : 0.0 ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Vector [tower][tkrplane] reporting the normalized of number of events with ToT==0  for both controller 0 and controller 1. The used normalization factor is the number of Tkr Digis in that [tower][tkrplane]. This is a good indicator of events with TIMING PROBLEMS. </description>
    </object>


      <object>
      <name> Normalized_ToT_0_TowerPlane_err[16][36] </name>
      <formula><![CDATA[foreachtower: foreachtkrplane: ( Rate_TkrDigi_TowerPlane[tower][tkrplane] >0 &&  Rate_TkrDigi_TowerPlane_err[tower][tkrplane]>0 ) ? sqrt((1./double(pow(Rate_TkrDigi_TowerPlane[tower][tkrplane]/Rate_TkrDigi_TowerPlane_err[tower][tkrplane],2)))*(Rate_ToT_0_TowerPlane[tower][tkrplane]/Rate_TkrDigi_TowerPlane[tower][tkrplane])*(1-(Rate_ToT_0_TowerPlane[tower][tkrplane]/Rate_TkrDigi_TowerPlane[tower][tkrplane]))) : 0.0 ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Vector [tower][tkrplane] reporting the error in quantity  OutF_Normalized_ToT_0_TowerPlane. </description>
    </object>

     
     

<object>
      <name> ToT_con0_255_TowerPlane[16][36] </name>
      <formula><![CDATA[foreachtower: foreachtkrplane: ToT_con0_TowerPlane[tower][tkrplane]==255 ]]></formula>
      <cut><![CDATA[ condsummary&30]]></cut>
      <type> rate </type>
      <description> Vector [tower][tkrplane] reporting the rate of evts with ToT==255 (overlapped trigger) in controller 0.  </description>
    </object>

    <object>
      <name> ToT_con1_255_TowerPlane[16][36] </name>
      <formula><![CDATA[foreachtower: foreachtkrplane: ToT_con1_TowerPlane[tower][tkrplane]==255 ]]></formula>
      <cut><![CDATA[ condsummary&30]]></cut>
      <type> rate </type>
      <description> Vector [tower][tkrplane] reporting the rate of evts with ToT==255 (overlapped trigger) in controller 1.  </description>
    </object>

     <object>
      <name> ToT_255_TowerPlane[16][36] </name>
      <formula><![CDATA[foreachtower: foreachtkrplane: ToT_con0_TowerPlane[tower][tkrplane]==255 || ToT_con1_TowerPlane[tower][tkrplane]==255]]></formula>
      <cut><![CDATA[ condsummary&30]]></cut>
      <type> rate </type>
      <description> Vector [tower][tkrplane] reporting the rate of evts with ToT==255 (overlapped trigger) in either controller 0 or controller 1.  </description>
    </object>


         <object>
      <name> Normalized_ToT_255_TowerPlane[16][36]  </name>
      <formula><![CDATA[foreachtower: foreachtkrplane: Rate_TkrDigi_TowerPlane[tower][tkrplane] >0 ? (Rate_ToT_255_TowerPlane[tower][tkrplane]/Rate_TkrDigi_TowerPlane[tower][tkrplane]) : 0.0 ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Vector [tower][tkrplane] reporting the normalized number of events with ToT> 250  for either controller 0 or controller 1. The used normalization factor is the number of Tkr Digis in that [tower][tkrplane]. This is a good indicator of events with REMNANT INFORMATION FROM PREVIOUS EVENTS. </description>
    </object>


      <object>
      <name> Normalized_ToT_255_TowerPlane_err[16][36] </name>
      <formula><![CDATA[foreachtower: foreachtkrplane: ( Rate_TkrDigi_TowerPlane[tower][tkrplane] >0 && Rate_TkrDigi_TowerPlane_err[tower][tkrplane]>0 ) ? sqrt((1./double(pow(Rate_TkrDigi_TowerPlane[tower][tkrplane]/Rate_TkrDigi_TowerPlane_err[tower][tkrplane],2)))*(Rate_ToT_255_TowerPlane[tower][tkrplane]/Rate_TkrDigi_TowerPlane[tower][tkrplane])*(1-(Rate_ToT_255_TowerPlane[tower][tkrplane]/Rate_TkrDigi_TowerPlane[tower][tkrplane]))) : 0.0 ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Vector [tower][tkrplane] reporting the error in quantity  OutF_Normalized_ToT_255_TowerPlane. </description>
    </object>

     

    <object>
      <name> ToT_con0_Trunc_1_249_TowerPlane[16][36] </name>
      <formula><![CDATA[foreachtower: foreachtkrplane: ToT_con0_TowerPlane[tower][tkrplane] ]]></formula>
      <cut><![CDATA[ condsummary&30]]></cut>
      <type> truncatedmean[1,249] </type>
      <description> Vector [tower][trkplane] reporting the truncated mean (only range [1,249] is used) ToT value per event in controller 0. This is the AVERAGE TOT WITHOUT OUTLIERS for controller 0. </description>
    </object>

    <object>
      <name> ToT_con1_Trunc_1_249_TowerPlane[16][36] </name>
      <formula><![CDATA[foreachtower: foreachtkrplane: ToT_con1_TowerPlane[tower][tkrplane] ]]></formula>
      <cut><![CDATA[ condsummary&30]]></cut>
      <type> truncatedmean[1,249] </type>
      <description> Vector [tower][trkplane] reporting the truncated mean (only range [1,249] is used) ToT value per event in controller 1. This is the AVERAGE TOT WITHOUT OUTLIERS for controller 1. </description>
    </object>


     <object>
      <name> ToT_0_WhenTkrHitsExist_TowerPlane[16][36] </name>
      <formula><![CDATA[foreachtower: foreachtkrplane: (IsTkrDigi_TowerPlane[tower][tkrplane]>0.5) && (ToT_con0_TowerPlane[tower][tkrplane]==0) && (ToT_con1_TowerPlane[tower][tkrplane]==0) && (TkrHitsTowerPlane[tower][tkrplane]>0)]]></formula>
      <cut><![CDATA[ condsummary&30]]></cut>
      <type> rate </type>
      <description> Vector [tower][tkrplane] reporting the rate of ToT==0 in both controller 0 and controller 1, when TkrDigi exists and there is at least one hit. </description>
    </object>


       <object>
      <name> Normalized_ToT_0_WhenTkrHitsExist_TowerPlane[16][36]  </name>
      <formula><![CDATA[foreachtower: foreachtkrplane: Rate_TkrDigi_TowerPlane[tower][tkrplane] >0 ? (Rate_ToT_0_WhenTkrHitsExist_TowerPlane[tower][tkrplane]/Rate_TkrDigi_TowerPlane[tower][tkrplane]) : 0.0 ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Vector [tower][tkrplane] reporting the normalized of number of events with ToT==0  for both controller 0 and controller 1 when there is at least one hit in that tower,tkrplane. The used normalization factor is the number of Tkr Digis in that [tower][tkrplane]. This quantity is more demanding than Normalized_ToT_0_TowerPlane. </description>
    </object>


      <object>
      <name> Normalized_ToT_0_WhenTkrHitsExist_TowerPlane_err[16][36] </name>
      <formula><![CDATA[foreachtower: foreachtkrplane: ( Rate_TkrDigi_TowerPlane[tower][tkrplane] >0 && Rate_TkrDigi_TowerPlane_err[tower][tkrplane]>0 ) ?  sqrt((1./double(pow(Rate_TkrDigi_TowerPlane[tower][tkrplane]/Rate_TkrDigi_TowerPlane_err[tower][tkrplane],2)))*(Rate_ToT_0_WhenTkrHitsExist_TowerPlane[tower][tkrplane]/Rate_TkrDigi_TowerPlane[tower][tkrplane])*(1-(Rate_ToT_0_WhenTkrHitsExist_TowerPlane[tower][tkrplane]/Rate_TkrDigi_TowerPlane[tower][tkrplane]))) : 0.0 ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Vector [tower][tkrplane] reporting the error in quantity  OutF_Normalized_ToT_0_WhenTkrHitsExist_TowerPlane. </description>
    </object>

 
      

     <!-- Calorimeter -->


     <object>
      <name> CalXHit_Hit_TowerCalLayerCalColumn[16][8][12] </name>
      <formula><![CDATA[CalXHit_TowerCalLayerCalColumn]]></formula>
      <cut><![CDATA[condsummary&30 && !(condsummary&32)]]></cut>
      <type> rate </type>
      <description> Vector[tower][callayer][calcolumn] reporting the hit rate in a crystal defined by the coordinates tower,callayer,calcolumn. Periodic triggers are NOT taken into account. </description>
    </object>

     <object>
       <name> Norm_CalXHit_Hit_TowerCalLayerCalColumn[16][8][12]  </name>
      <formula><![CDATA[foreachtower: foreachcallayer: foreachcalcolumn: Rate_Trigger_NOTPeriodic >0 ? (Rate_CalXHit_Hit_TowerCalLayerCalColumn[tower][callayer][calcolumn]/Rate_Trigger_NOTPeriodic) : 0.0 ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Vector [tower][callayer][calcolumn] reporting the normalized number hits in crystal log defined by coordinates tower,callayer,callcolumn. The used normalization factor is the number of NOT periodic triggers. This is an indicator of the OCCUPANCY IN THE CALORIMETER. </description>
    </object>



      <object>
      <name> Norm_CalXHit_Hit_TowerCalLayerCalColumn_err[16][8][12]  </name>
      <formula><![CDATA[foreachtower: foreachcallayer: foreachcalcolumn: ( Rate_Trigger_NOTPeriodic >0 && Rate_CalXHit_Hit_TowerCalLayerCalColumn[tower][callayer][calcolumn] >0 ) ? (Rate_CalXHit_Hit_TowerCalLayerCalColumn[tower][callayer][calcolumn]/Rate_Trigger_NOTPeriodic * TMath::Sqrt(pow(Rate_Trigger_NOTPeriodic_err/Rate_Trigger_NOTPeriodic,2)+pow(Rate_CalXHit_Hit_TowerCalLayerCalColumn_err[tower][callayer][calcolumn]/Rate_CalXHit_Hit_TowerCalLayerCalColumn[tower][callayer][calcolumn],2))) : 0.0 ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <source>output</source>
      <type> outputfloat </type>
      <description> Vector [tower][callayer][calcolumn]  reporting the error in quantity  OutF_Normalized_CalXHit_Hit_TowerCalLayerCalColumn. </description>
    </object>



     <object>
      <name> CalXHit_Hit_TowerCalLayer[16][8] </name>
      <formula><![CDATA[CalXHit_TowerCalLayer]]></formula>
      <cut><![CDATA[condsummary&30 && !(condsummary&32)]]></cut>
      <type> rate </type>
      <description> Vector[tower][callayer] reporting the hit rate in a calorimeter layer defined by the coordinates tower,callayer. Periodic triggers are NOT taken into account. </description>
    </object>


    

     <object>
      <name> CalXHit_ZEROHit_TowerCalLayerCalColumn[16][8][12] </name>
      <formula><![CDATA[ foreachtower: foreachcallayer: foreachcalcolumn: (CalXHit_TowerCalLayerCalColumn[tower][callayer][calcolumn]<0.5)]]></formula>
      <cut><![CDATA[condsummary&30 && !(condsummary&32)]]></cut>
      <type> counter </type>
      <description> Vector[tower][callayer][calcolumn] reporting the number ZERO hits in a crystal defined by the coordinates tower,callayer,calcolumn. Periodic triggers are NOT taken into account. </description>
    </object>
     

     
<!--  TEST quantity
      <object>
      <name> CalXHit_ZEROHit_TowerCalLayer[16][8] </name>
      <formula><![CDATA[ foreachtower: foreachcallayer: (CalXHit_TowerCalLayer[tower][callayer]<0.5)]]></formula>
      <cut><![CDATA[condsummary&30 && !(condsummary&32)]]></cut>
      <type> counter </type>
      <description> Vector[tower][callayer] reporting the number of ZERO hits in a calorimeter layer defined by the coordinates tower,callayer. Periodic triggers are NOT taken into account. </description>
    </object>
-->

      <object>
      <name> CalXHit_ZEROHit_TowerCalLayer[16][8] </name>
      <formula><![CDATA[ foreachtower: foreachcallayer: (RFun::loopovercalcolumns(CalXHit_TowerCalLayerCalColumn[tower][callayer])<0.5)]]></formula>
      <cut><![CDATA[ condsummary&30 && !(condsummary&32)]]></cut>
      <type> counter </type>
      <description> Vector[tower][callayer] reporting the number of ZERO hits in a calorimeter layer defined by the coordinates tower,callayer. Periodic triggers are NOT taken into account.  </description>
    </object>




     <object>
      <name> CalXHit_ZEROHit_Fraction_TowerCalLayer[16][8] </name>
      <formula><![CDATA[ foreachtower: foreachcallayer: Counter_CondsummaryBitAnd30_NOTPeriodic>0 ? (double(Counter_CalXHit_ZEROHit_TowerCalLayer[tower][callayer])/double(Counter_CondsummaryBitAnd30_NOTPeriodic)) : 0.0 ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <source>output</source>
      <type> outputfloat </type>
     
      <description> Fraction of events with ZERO hits in a calorimeter layer defined by the coordinates tower,callayer. Periodic triggers are NOT taken into account. The normalization factor used to compute the fraction is CondsummaryBitAnd30_NOTPeriodic_Counter</description>
     </object>
     
      <object>
      <name> CalXHit_ZEROHit_Fraction_TowerCalLayer_err[16][8] </name>
      <formula><![CDATA[ foreachtower: foreachcallayer: Counter_CondsummaryBitAnd30_NOTPeriodic>0 ? sqrt((1./double(Counter_CondsummaryBitAnd30_NOTPeriodic))*(double(Counter_CalXHit_ZEROHit_TowerCalLayer[tower][callayer])/double(Counter_CondsummaryBitAnd30_NOTPeriodic))*(1-(double(Counter_CalXHit_ZEROHit_TowerCalLayer[tower][callayer])/double(Counter_CondsummaryBitAnd30_NOTPeriodic)))): 0.0 ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <source>output</source>
      <type> outputfloat </type>
     
      <description> Error in quantity CalXHit_ZEROHit_Fraction_TowerCalLayer. </description>
     </object>


      


      <object>
      <name> CalXHit_ZEROHit_Frac_TowerCalLayerCalColumn[16][8][12] </name>
      <formula><![CDATA[ foreachtower: foreachcallayer: foreachcalcolumn: Counter_CondsummaryBitAnd30_NOTPeriodic>0 ? (double(Counter_CalXHit_ZEROHit_TowerCalLayerCalColumn[tower][callayer][calcolumn])/double(Counter_CondsummaryBitAnd30_NOTPeriodic)) : 0.0 ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <source>output</source>
      <type> outputfloat </type>
     
      <description> Fraction of events with ZERO hits in a calorimeter crystal defined by the coordinates tower,callayer,calcolumn. Periodic triggers are NOT taken into account. The normalization factor used to compute the fraction is CondsummaryBitAnd30_NOTPeriodic_Counter</description>
     </object>
     
      <object>
      <name> CalXHit_ZEROHit_Frac_TowerCalLayerCalColumn_err[16][8][12] </name>
      <formula><![CDATA[ foreachtower: foreachcallayer: foreachcalcolumn: Counter_CondsummaryBitAnd30_NOTPeriodic>0 ? sqrt((1./double(Counter_CondsummaryBitAnd30_NOTPeriodic))*(double(Counter_CalXHit_ZEROHit_TowerCalLayerCalColumn[tower][callayer][calcolumn])/double(Counter_CondsummaryBitAnd30_NOTPeriodic))*(1-(double(Counter_CalXHit_ZEROHit_TowerCalLayerCalColumn[tower][callayer][calcolumn])/double(Counter_CondsummaryBitAnd30_NOTPeriodic)))): 0.0 ]]></formula>
      <cut><![CDATA[ ]]></cut>
      <source>output</source>
      <type> outputfloat </type>
     
      <description> Error in quantity CalXHit_ZEROHit_Fraction_TowerCalLayerCalColumn. </description>
     </object>

      
     
    

     <object>
      <name> CalXHit_MHit_TowerCalLayer[16][8] </name>
      <formula><![CDATA[ foreachtower: foreachcallayer: RFun::loopovercalcolumns(CalXHit_TowerCalLayerCalColumn[tower][callayer])]]></formula>
      <cut><![CDATA[ condsummary&30 && !(condsummary&32)]]></cut>
      <type> mean </type>
      <description> Vector[tower][callayer] reporting the MEAN number of hits (per event) in a calorimeter layer defined by the coordinates tower,callayer. Periodic triggers are NOT taken into account. </description>
    </object>





     <object>
      <name> CalXHit_NTowerHit_Tower[16] </name>
      <formula><![CDATA[ foreachtower: RFun::loopovercallayers(CalXHit_TowerCalLayer[tower])]]></formula>
      <cut><![CDATA[ condsummary&30 && !(condsummary&32)]]></cut>
      <type> rate </type>
      <description> Vector[tower] reporting the rate of calorimeter crystal hits in that tower. Periodic triggers are NOT taken into account. </description>
    </object>

 

     <object>
      <name> CalXHit_Hit </name>
      <formula><![CDATA[ RFun::loopovertowerANDcallayers(CalXHit_TowerCalLayer)]]></formula>
      <cut><![CDATA[condsummary&30 && !(condsummary&32) ]]></cut>
      <type> rate </type>
      <description> Rate of calorimeter crystal hits (all towers, layers and columns). Periodic triggers are NOT taken into account. </description>
    </object>


     <object>
      <name> Cal_NHit </name>
      <formula><![CDATA[ RFun::loopovertowerANDcallayers(CalXHit_TowerCalLayer)]]></formula>
      <cut><![CDATA[ condsummary&30 && !(condsummary&32)]]></cut>
      <type> mean </type>
      <description> MEAN number of calorimeter crystal hits per event (integrated over all towers, layers and columns). Periodic triggers are NOT taken into account. </description>
    </object>

      <object>
      <name> Cal_NHit_ZeroNotCounted </name>
      <formula><![CDATA[ RFun::loopovertowerANDcallayers(CalXHit_TowerCalLayer)]]></formula>
      <cut><![CDATA[ condsummary&30 && !(condsummary&32) && RFun::loopovertowerANDcallayers(CalXHit_TowerCalLayer) >0]]></cut>
      <type> mean </type>
      <description> MEAN number of calorimeter crystal hits per event (integrated over all towers, layers and columns). Periodic triggers are NOT taken into account. Only events with more than one CalXHit are taken into account. </description>
    </object>



     

  </outputList>

  <eventCut><![CDATA[ ]]></eventCut>
  <timestamp> timestampdouble </timestamp>
</monitoring>
